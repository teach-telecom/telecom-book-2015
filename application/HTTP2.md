##Протокол HTTP/2 и его реализация
#Работа над новым протоколом для всемирной сети находится на завершающем этапе. HTTP/2 должен решить многие застарелые проблемы HTTP/1.1 и дать возможность Интернету развиваться дальше. Есть довольно хорошая статья «http2 explained» , посвященная новому протоколу HTTP/2, разъясняющая предпосылки его создания и наглядно демонстрирующая его возможности и принципы работы. Статья, тем не менее, не содержит какой-либо детальной технической спецификации протокола. Есть также отличная книга Ilya Grigorik «High-Performance Browser Networking» , веб-версия которой свободно доступна , и которая также содержит интересные детали о прародителе HTTP/2 - SPDY и самом HTTP/2 (правда уже немного устаревшие). После её прочтения я вдохновился создать реализацию HTTP/2-протокола и в процессе досконально изучить новый протокол. Эта статья - небольшой отчёт за последние два месяца убитого свободного времени.
#Спецификация HTTP/2
Разработкой протокола занимается рабочая группа IETF HTTPbis. Спецификация имеет свой веб-сайт , в соответствии с современной традицией свободной разработки, сайт и репозиторий исходных текстов хостятся на Github .

Спецификация в свою очередь разделена на три документа:

 • Спецификация протокола HTTP/2. Текущий черновик - draft-12

 • Спецификация сжатия заголовков HPACK. Текущий черновик - draft-07

 • Спецификация альтернативных сервисов. Текущий черновик - draft-01

Самые важные факты о HTTP/2
 • HTTP/2 не меняет парадигмы HTTP/1.1, т.е. с точки зрения веб-приложения ничего не меняется: остаются всё те же методы GET, POST и т.д., по-прежнему присутствуют HTTP-заголовки и тело HTTP-запроса/ответа. Просто по сети это передаётся в другом формате.

 • HTTP/2, в отличии от HTTP/1.1, сохраняет своё состояние между запросами (является stateful), поэтому порядок отправки/приёма фреймов важен.

 • HTTP/2 - это бинарный протокол. Поток делится на фреймы, имеющие фиксированную структуру и размер. Нет необходимости в парсинге для поиска границ сообщений.

 • HTTP/2 - это двусторонний поток данных, в котором мультиплексированы фреймы от разных запросов/ответов. Т.о. нет необходимости более чем в одном tcp-соединении для одновременной передачи различных данных.

 • HTTP/2 может управлять приоритетом, зависимостями и скоростью передачи запрашиваемых ресурсов, т.е. клиент может указать серверу какие ресурсы он хочет получить в первую очередь и регулировать объём доступной полосы персонально для каждого ресурса.

 • HTTP/2 может сжимать HTTP-заголовки и данные

 • В HTTP/2 сервер имеет возможность инициировать передачу данных клиенту (Server Push)

Известные программные реализации протокола HTTP/2
Ведётся учёт известных реализаций протокола, который отражается на wiki-странице проекта группы HTTPbis.

Наиболее совершенную, на мой взгляд, реализацию имеет проект nghttp2 -- это C-библиотека, реализующая спецификацию протокола. Именно её используют некоторые другие проекты, например libcurl и mruby-http2. Также стоит отметить реализацию Mozilla, которая в данный момент используется в свежих сборках Firefox.

Есть в списке и реализация на языке Perl http2-perl, но последний коммит был сделан в августе 2013 и анонсировал неполную поддержку draft-04, т.о. проект безнадёжно устарел.

Protocol::HTTP2
Мне показалось, что наиболее подходящим именем для реализации протокола на языке Perl будет имя Protocol::HTTP2 . По аналогии с модулем Protocol::WebSocket , API которого, кстати, стало прототипом для нового модуля (хотя в итоге я ещё больше его упростил).

На данный момент модуль всё ещё на стадии разработки, хотя большая часть спецификации и самые важные элементы уже реализованы.

Основная идея модуля -- это полное абстрагирование от сетевого уровня и реализация исключительно протокольного уровня. Таким образом модуль не открывает сетевых соединений, никак не управляет сокетом, а имеет дело лишь бинарным потоком байт, которым его снабжает приложение.

Например, так может выглядеть код приложения (упрощённо):


# вычитать данные из сокета
while ( sysread $socket, my $data, 4096 ) {

    # передать данные обработчику протокола
    $http2_client->feed($data);
}

# последовательно отправлять генерируемые данные в сокет
while (my $frame = $http2_client->next_frame ) {
    syswrite $socket, $frame;
}
Приложению требуется лишь предварительно зарегистрировать свои callback-функции, на определённые события, например, получение HTTP-запроса или HTTP-ответа.

Такой принцип делает возможным создание клиента/сервера на основе любой реализации цикла событий (AnyEvent, IO::Async), а также на основе форков/тредов или любой другой модели сетевых серверов/клиентов.

Естественно это накладывает ограничения на обработку событий, которые должны происходить с задержкой, например, всевозможные таймауты. Но, к счастью, в протоколе HTTP/2 таких моментов немного и они несущественны.

Protocol::HTTP2::Client
Модуль для реализации клиента протокола HTTP/2.

Для понимания начнём с примера:

use Protocol::HTTP2::Client;
 
# Создать объект клиента
my $client = Protocol::HTTP2::Client->new;
 
# Подготовить запрос
$client->request(
 
    # HTTP/2 заголовки
    ':scheme'    => 'http',
    ':authority' => 'localhost:8000',
    ':path'      => '/',
    ':method'    => 'GET',
 
    # HTTP/1.1 заголовки
    headers      => [
        'accept'     => '*/*',
        'user-agent' => 'perl-Protocol-HTTP2/0.08',
    ],
 
    # Функция-callback вызываемая после получения ответа от сервера
    on_done => sub {
        my ( $headers, $data ) = @_;
        ...
    },
);
# Дальше идёт работа с сокетом (отправка/приём)
...
В HTTP/2 есть специальные заголовки, начинающиеся с двоеточия. В примере выше представлены все заголовки необходимые для запроса (они обязательны). В случае ответа сервера, присутствует заголовок :status. Отдельно указываются заголовки HTTP/1.1, которые увидит веб-приложение при получении запроса. Функция-callback on_done будет вызвана после получения данных от сервера: ссылка на массив с заголовками и данные.

Метод request возвращает сам объект $client, поэтому можно объединить в цепочку несколько запросов. Они будут отправлены последовательно, но отправка запросов будет происходить до получения ответа сервера. Т.е. можно сделать запрос на тысячи ресурсов и потом неспешно собирать их из ответа сервера. Сервер будет отправлять потоки в произвольном порядке, мультиплексируя все части в одном соединении.

API получилось, на мой взгляд, достаточно простым. В дальнейшем можно будет добавить опции для управления приоритетом и зависимостями запрашиваемых ресурсов.

Protocol::HTTP2::Server
Модуль для реализации сервера протокола HTTP/2.

Есть достаточно большой пример из документации модуля , но нас больше интересует именно получение запроса.

# Создать объект сервера (персонально для каждого клиента)
my $server;
$server = Protocol::HTTP2::Server->new(

    # Функция-callback при получении запроса
    on_request => sub {
        my ( $stream_id, $headers, $data ) = @_;
        my $message = "hello, world!";
 
        # Ответ клиенту
        $server->response(
            ':status' => 200,
            stream_id => $stream_id,
 
            # HTTP/1.1 Headers
            headers   => [
                'server'         => 'perl-Protocol-HTTP2/0.08',
                'content-length' => length($message),
                'cache-control'  => 'max-age=3600',
                'date'           => 'Fri, 18 Apr 2014 07:27:11 GMT',
                'last-modified'  => 'Thu, 27 Feb 2014 10:30:37 GMT',
            ],
 
            # Content
            data => $message,
        );
    },
);
Каждый запрос в HTTP/2 порождаёт новый поток - stream. Потоки имеют свои номера stream_id. Поэтому функция-callback получает помимо заголовков и тела запроса ещё и информацию о номере потока, чтобы знать в какой поток направить ответ.

Шувгей
Знаете ли вы, что такое Шувгей ? В легендах из тех мест, где я обитаю, это ветер нечисти. Именно такое название я решил дать пробной реализации HTTP/2 веб-сервера на основе AnyEvent и Protocol::HTTP2. С одной стороны это своеобразный ответ питоновскому веб-серверу Торнадо, а с другой стороны - дань карго-культу странных названий из локального фольклора. Вон японцы дают имена Годзилла, Хероку и получаются вполне успешные проекты, может дело именно в названиях? ;)

Проект Shuvgey выложен на github и на CPAN . Веб сервер следует спецификации Plack/PSGI, поэтому его можно также запускать и через plackup:

plackup -s Shuvgey --no_tls app.psgi
или непосредственно:

shuvgey --tls_crt path/to/cert --tls_key path/to/key app.psgi
Как видно веб-сервер может работать как без TLS на чистом протоколе HTTP/2, так и с использованием шифрования. Кроме того есть опция --upgrade, которая позволяет веб-серверу апгрейдить соединение с HTTP/1.1 до HTTP/2, но это возможно только для соединений без шифрования.

Firefox + Shuvgey
Чтобы увидеть веб-сайте по протоколу HTTP/2 надо использовать браузер, который поддерживает последний черновик HTTP/2. Можно загрузить «ночные» сборки Firefox 32.0a. Для активации HTTP/2 потребуется установить опцию на странице настроек about:config:

network.http.spdy.enabled.http2draft=true
Также придётся выключить опцию (вероятно это баг в Net::SSLeay):

network.http.spdy.enforce-tls-profile=false
Конечно не всё ещё работает гладко, мне приходилось наблюдать сбросы потоков, с этим предстоит разобраться, но в принципе прототип вполне рабочий.

Бенчмарки
Я попробовал сделать бенчмарк Shuvgey, чтобы оценить насколько всё ужасно сделано. Но оказалось всё не так уж плохо, даже на таком начальном этапе.

Для теста я взял утилиту h2load из проекта nghttp2:

# Вариант без TLS
$ h2load http://127.0.0.1:5000/ -n 10000
finished in 11 sec, 601 millisec and 151 microsec, 861 req/s, 24 kbytes/s

# Вариант с TLS
$ h2load https://127.0.0.1:5000/ -n 10000
finished in 13 sec, 790 millisec and 799 microsec, 725 req/s, 20 kbytes/s
Для сравнения c HTTP/1.1 взял веб-сервер Twiggy (как наиболее близкий по технологии):

# Вариант без TLS
$ ab2 -n 10000 -c 1 http://127.0.0.1:5000/
Requests per second:    1158.82 [#/sec] (mean)
Т.е. в варианте без TLS реализация HTTP/2 проигрывает реализации HTTP/1.1 примерно на четверть (861 против 1158 запросов в секунду).

В принципе это объяснимо, т.к. HTTP/2 достаточно интенсивно нагружает процессор, т.к. требуется обработка поступающих фреймов и декодирование заголовков. В однопоточном приложении это становится критическим фактором.

Но не стоит думать, что HTTP/2 плох, ведь перед ним не ставилась цель упростить протокол, а ставилась задача снижения задержки и уменьшения количества соединений при одновременном увеличении количества загружаемых ресурсов.

Итог
Работа над модулем протокола и веб-сервером продолжится. Думаю, что продолжу писать небольшие заметки о протоколе HTTP/2. Например, в следующей статье можно будет рассказать о сжатии заголовков HPACK. Это довольно интересный алгоритм и обеспечивает эффективное сжатие заголовков, особенно при большой серии однообразных запросов. Текущая реализация содержится в модуле Protocol::HTTP2::HeaderCompression
#Разъяснение http2
IT-стандарты*, Сетевые технологии*, Веб-разработка*
На днях Даниэль Штенберг, один из участников группы HTTPbis IETF, которая ведёт разработку протокола http2, опубликовал в своём блоге крайне интересный документ «http2 explained». Небольшой PDF-документ на 26 страницах весьма доступным языком рассказывает о предпосылках и деталях реализации протокола http2.

Как мне кажется, на сегодняшний день это одно из самых лучших разъяснений о том, что такое протокол http2, зачем он нужен, как он повлияет на веб-разработку и какое будущее ждёт Интернет в связи с его появлением. Думаю, что всем людям, причастным к веб-разработке и веб-строению, информация будет полезна, ведь ожидается, что стандарт http2 будет принят уже в июне этого года после завершающей встречи группы HTTPbis в Нью Йорке.

Многие современные браузеры уже в той или иной степени поддерживают последние версии черновика http2, поэтому можно ожидать, что через короткий период времени (недели) после принятия стандарта, все клиенты будут его поддерживать. Многие крупные интернет-компании, такие как Google, Facebook и Twitter уже испытывают свои веб-сервисы для работы с http2.

Поэтому, чтобы внезапно в один прекрасный день не оказаться в мире, который работает на протоколе, о котором вы только что-то слышали краем уха и не представляете, что он из себя представляет и как работает, советую взглянуть на этот документ. Лично я оказался под таким впечатлением, что сделал перевод на русский язык (Update: перевод теперь доступен непосредственно в этой статье). Пожалуйста, если вы обнаружили, неточности перевода или опечатки, сообщайте. Надеюсь, что в итоге документ получится максимально понятным и полезным большому кругу людей.

http2


История, протокол, реализации и будущее
daniel.haxx.se/http2

История

Это документ, описывающий http2 с позиции технического и протокольного уровня. Первоначально он появился как презентация, которую я представлял в Стокгольме в апреле 2014 года. Я получил с тех пор множество вопросов о содержимом презентации от людей, которые не смогли посетить мероприятие, поэтому я решил сконвертировать его в полноценный документ с деталями и надлежащими пояснениями.
На момент написания (28 апреля 2014), окончательная спецификация http2 не завершена и не выпущена. Текущая версия черновика называется draft-12, но мы ожидаем увидеть ещё по крайне мере одну версию перед тем как http2 будет завершён. Данный документ описывает текущую ситуацию, которая может измениться или не измениться в окончательной спецификации. Все ошибки в данном документе – мои собственные, появившиеся по моей вине. Пожалуйста сообщите мне о них и я выпущу обновление с исправлениями.

Версия этого документа – 1.2.

Автор

Меня зовут Даниэль Штенберг и я работаю в Mozilla. Открытым программным обеспечением и сетями я занимаюсь уже более двадцати лет в различных проектах. Вероятно, я наиболее известен, как основной разработчик curl и libcurl. Многие годы я был вовлечён в рабочую группу IETF HTTPbis и работал как над поддержкой HTTP 1.1, для соответствия новейшим требованиям, так и работой над стандартизацией http2.

Email: daniel@haxx.se
Twitter: @bagder
Web: daniel.haxx.se
Blog: daniel.haxx.se/blog

Помогите!


Если вы обнаружили опечатки, упущения, ошибки и явную ложь в этом документе, пожалуйста отправьте мне исправленную версию параграфа и я выпущу исправленную версию. Я должным образом отмечу всех, кто помог! Надеюсь, что со временем получиться сделать текст лучше.

Этот документ доступен по ссылке daniel.haxx.se/http2

Лицензия

Этот документ лицензируется под лицензией Creative Commons Attribution 4.0: creativecommons.org/licenses/by/4.0


HTTP сегодня


HTTP 1.1 стал протоколом, который используется поистине для всего в Интернете. Огромные инвестиции были вложены в протоколы и инфраструктуру, которые теперь извлекают из этого прибыль. Дошло до того, что сегодня зачастую проще запустить что-либо поверх HTTP, чем создавать что-то новое вместо него.

HTTP 1.1 огромен


Когда HTTP был создан и выпущен в мир, он, вероятно, воспринимался скорее как простой и прямолинейный протокол, но время показало, что это не так. HTTP 1.0 в RFC 1945 – это 60 страниц спецификации, выпущенной в 1996. RFC 2616, который описывал HTTP 1.1, был выпущен лишь тремя годами позднее в 1999 и значительно разросся до 176 страниц. Кроме того, когда мы в IETF работали над обновлением спецификации, она была разбита на шесть документов с ещё большим числом страниц в итоге. Без сомнений, HTTP 1.1 большой и включает мириады деталей, тонкостей и в не меньшей степени опциональных разделов.

Мир опций


Природа HTTP 1.1, заключённая в наличии большого числа мелких деталей и опций, доступных для последующего изменения, вырастила экосистему программ, где нет ни одной реализации, которая бы воплотила всё – и, на самом деле, невозможно точно сказать, что представляет из себя это «всё». Что привело к ситуации, когда возможности, которые первоначально мало использовались появлялись лишь в небольшом числе реализаций, и те кто их реализовывал после наблюдали незначительное их использование.
Позже это вызывало проблемы в совместимости, когда клиенты и сервера начали активнее использовать подобные возможности. Конвейерная обработка HTTP (HTTP pipelining) – это один из показательных примеров подобных возможностей.

Неполноценное использование TCP


HTTP 1.1 прошёл трудный путь, чтобы по настоящему воспользоваться всей мощью и производительностью, которую даёт TCP. HTTP-клиенты и браузеры должны быть по-настоящему изобретательными, чтобы найти способы для уменьшения времени загрузки страницы.

Прочие эксперименты, которые параллельно велись в течении многих лет, также подтверждали, что TCP не так просто заменить, и поэтому мы продолжаем работать над улучшением как TCP, так и протоколов, работающих поверх него.

TCP можно легко начать использовать полноценно, чтобы избежать пауз или периодов времени, которые могли быть использованы для отправки или приёма большего количества данных. Последующие главы осветят некоторые из этих недостатков использования.

Размер передачи и число объектов


Когда смотришь на тенденции развития некоторых наиболее популярных на сегодня сайтов и сравниваешь сколько занимает времени загрузка их главной страницы, тенденции становятся очевидными. За последние несколько лет количество данных, которые требуется передать постепенно выросло до отметки 1,5Мб и выше, но что наиболее важно для нас в этом контексте, так это число объектов, которое в среднем теперь близко к сотне. Сто объектов необходимо загрузить, чтобы отобразить всю страницу целиком.

Как показывает график, тренд был растущим, но позднее нет никаких признаков, что он будет дальше меняться.
![](https://habrastorage.org/getpro/habr/post_images/da8/b23/e65/da8b23e6584457ec459fc9f74505a868.png)
#http2 начался со SPDY


SPDY – это протокол, который был разработан и инициирован в Google. Они определённо разрабатывали его открыто и приглашали всех участвовать, но было очевидно, что они получают огромные преимущества имея контроль над двумя реализациями: популярный веб-браузер и значительная популяция серверов с активно используемыми сервисами.

Когда группа HTTPbis решила начать работать над http2, SPDY уже был проверен как рабочая концепция. Он показал, что его возможно развернуть в Интернете, и были опубликованные цифры, которые показывали насколько он справлялся. Работа над http2 впоследствии началась с черновика SPDY/3, который по большому счёту стал черновиком http2 draft-00 после пары операций поиска с заменой.

Концепция http2


Так для чего создан http2? Где границы, которые ограничивают область работы группы HTTPbis?
Они, на самом деле, достаточно чёткие и накладывают заметные ограничения на способность команды к инновациям.
#Она должна поддерживать парадигмы HTTP. Это по-прежнему протокол, где клиенты отправляют запросы на сервер поверх TCP.
Ссылки http:// и https:// не могут быть изменены. Нельзя добавить новую схему или сделать что-нибудь подобное. Количество контента, которое использует подобную адресацию слишком велико, чтобы когда-либо ожидать подобного изменения.
HTTP1 серверы и клиенты будут существовать ещё десятилетия, мы должны иметь возможность проксировать их к http2-серверам.
Следовательно, прокси должны быть способны конвертировать один в один возможности http2 в HTTP 1.1 для клиентов.
Удалить или уменьшить число опциональных частей в протоколе. Это даже не столько требование, сколько мантра, пришедшая от SPDY и команды Google. Настаивая на том, что все требования обязательны, у вас не будет возможности не делать чего-то сейчас, а потом попасть в ловушку.
Больше нет минорных версий. Было решено, что клиенты и серверы могут быть либо совместимы с http2, либо нет. Если окажется, что необходимо расширить протокол или изменить его, тогда появится http3. В http2 больше не будет минорных версий.


http2 для существующих URI схем


Как было отмечено ранее, уже существующие схемы URI не могут быть изменены, поэтому http2 должен использовать только их. Так как сегодня они используются для HTTP 1.x нам нужен явный способ для обновления протокола до http2 или как-то иначе попросить сервер использовать http2 вместо старых протоколов.

HTTP 1.1 уже имеет предопределённый способ для этого, так называемый Upgrade – заголовок, который позволяет серверу отправить ответ, используя новый протокол, при получении подобного запроса по старому протоколу. Ценой времени одной итерации запрос-ответ.

Расплата временем запроса-ответа не являлась тем, с чем команда SPDY могла согласиться, и, поскольку они также разрабатывали SPDY поверх TLS, они создали новое TLS-расширение, которое применялось для существенного сокращения согласования. Используя это расширение, названное NPN от Next Protocol Negotiation (согласование следующего протокола), клиент сообщает серверу по каким протоколам он бы хотел общаться и сервер может ответить наиболее предпочтительным из тех, которые он знает.

http2 для https://


Большое внимание в http2 было уделено тому, чтобы он правильно работал поверх TLS. SPDY работал только поверх TLS и было сильное желание сделать TLS обязательным и для http2, но консенсус не был достигнут и http2 будет выпущен с опциональным TLS. Однако, два известных разработчика спецификации чётко заявили, что они будут реализовывать только http2 поверх TLS: руководитель Mozilla Firefox и руководитель Google Chrome. Это два лидирующих браузера на сегодня.

Причины выбора режима только с TLS заключаются в заботе о неприкосновенности частной жизни пользователя, а ранние исследования показали высокий уровень успеха у новых протоколов при использовании TLS. Это связано с широко-распространённым допущением, что всё, что приходит на 80 порт – это HTTP 1.1, и некоторые промежуточные сетевые устройства вмешиваются и уничтожают трафик других протоколов, которые работают на этом порту.
#http2 согласование поверх TLS

Согласование следующего протокола (NPN) – это протокол, который использовался SPDY для согласования с TLS-серверами. Так как это не был настоящий стандарт, он был переработан в IETF и вместо него появился ALPN: Application Level Protocol Negotiation (согласование протокола на уровне приложения). ALPN продвигается для использования в http2, в то время как клиенты и серверы SPDY по-прежнему используют NPN.
То факт, что NPN появился первым, а для ALPN потребовалось время для прохождения стандартизации, привело к тому, что ранние реализации http2-клиентов и http2-серверов использовали оба этих расширения при согласовании http2.

http2 для http://


Как кратко отмечалось ранее, для текстового HTTP 1.1 для согласования http2 требуется отправить запрос серверу с заголовком Upgrade. Если сервер понимает http2, он ответит статусом «101 Switching» и затем начнёт использовать http2 в соединении. Вы конечно понимаете, что эта процедура обновления стоит времени одного полного сетевого запроса-ответа, но с другой стороны http2-соединение можно сохранять работоспособным и повторно использовать значительно дольше чем обычно используется HTTP1-соединение.

Несмотря на то, что некоторые представители браузеров настаивают, что они не будут реализовывать такой способ согласования http2, команда Internet Explorer выразила готовность его реализовать.

Протокол http2


Достаточно сказано о предпосылках, истории и политике, и теперь мы здесь. Давайте погрузимся в специфику протокола. Те части и концепции, которые слагают http2.

Бинарный протокол


http2 – это бинарный протокол.

Давайте попробуем осознать это на минутку. Если вы были знакомы с интернет-протоколами до этого, то велика вероятность, что инстинктивно вы сильно воспротивитесь этому факту и приготовите аргументы о том, как полезно иметь протоколы, использующие текст/ascii, и, что вы сотни раз писали HTTP 1.1 запросы руками просто подключившись телнетом к серверу.

http2 – бинарный для того, чтобы сделать формирование пакетов проще. Определение начала и конца пакета – одна из самых сложных задач в HTTP 1.1 и во всех текстовых протоколах в принципе. Уходя от опциональных пробелов и всевозможных способов записи одних и тех же вещей, мы делаем реализацию проще.

Кроме того, это позволяет гораздо проще разделять части связанные с самим протоколом и пакетом данных, что в HTTP1 беспорядочно перемешано.

Тот факт, что протокол позволяет использовать сжатие и часто работает поверх TLS также снижает ценность текста, так как вы в любом случае больше не увидите открытого текста в проводах. Мы просто должны придти к пониманию, что надо использовать анализатор Wireshark или что-то похожее, чтобы выяснить что происходит на уровне протокола в http2.

Отладка этого протокола, скорее будет выполняться такими утилитами, как curl, или путём анализа сетевого потока http2-диссектором Wireshark или чего-то подобного.

Бинарный формат


http2 отправляет фреймы. Существует множество различных фреймов, но все они имеют одинаковое строение:
Тип, длина, флаги, идентификатор потока и полезная нагрузка фрейма.
#Типичная критика http2


В процессе разработки протокола дебаты возникали снова и снова, и, конечно, есть некоторое число людей, который верят, что протокол получился совершенно неправильным. Я хотел бы отметить некоторые из наиболее типичных жалоб и аргументов против него: 

“Протокол спроектирован и сделан в Google”


Есть также вариации подразумевающие, что мир ещё больше зависит и контролируется Google. Это не правда. Протокол разработан внутри IETF тем же самым способом, как протоколы разрабатывались за последние 30 лет. Однако, все мы признательны Google за бесподобную работу над SPDY, который не только доказал, что возможно внедрять новый протокол таким способом, но и помог получить оценки того, что мы можем получить.

“Протокол полезен только для браузеров и больших сервисов”


В какой-то мере это так. Одна из главных причин, кроющейся за разработкой http2 – это исправление конвейерной обработки HTTP. Если в вашем случае не требовалась конвейерная обработка, то http2 не будет вам особо полезен. 
Это конечно не единственное достижение протокола, но самое значительное.

Как только сервисы начнут понимать всю мощь и возможности мультиплексированных потоков в одном соединении, я ожидаю, что мы увидим увеличение числа приложений, использующих http2.

Небольшие REST API и простые программные применения HTTP 1.x не получат больших преимуществ от перехода на http2. Но, тем не менее, будет совсем немного минусов для большинства пользователей.

“Использование TLS делает его медленным”


В некоторой степени это верно. Согласование TLS даёт небольшие накладные расходы, но уже прилагаются усилия для ещё большего уменьшения числа запросов-ответов для TLS. Расходы на выполнение TLS- шифрования, по сравнению с передачей открытым текстом, не так незначительны и явно заметны, поэтому больше процессорного и времени и электричества будет потрачено на том же самом трафике, как в небезопасном протоколе. Сколько и какие последствия это будет иметь – тема для высказываний и измерений. Смотрите, например, istlsfastyet.com как один из источников по теме.

http2 не обязывает использовать TLS, поэтому мы не должны смешивать термины.
Большинство пользователей в Интернете сегодня желают, чтобы TLS использовался более широко, и мы должны помогать защитить неприкосновенность частной жизни пользователей.

“Не ASCII-протокол всё портит”


Да, нам нравится идея возможности видеть протокол открыто, так как это упрощает отладку. Но текстовые протоколы гораздо более склоны к появлению ошибок и подвержены проблемам правильного синтаксического разбора.

Если вы действительно не можете принять бинарный протокол, тогда вы также не сможете принять и TLS, и сжатие в HTTP 1.x, которые существуют уже довольно длительное время.

Станет ли http2 широко распространён?


Ещё довольно рано говорить наверняка, но я могу предположить и оценить, и это я и собираюсь сделать здесь.
Скептики скажут «смотрите как хорошо был сделан IPv6», как пример нового протокола, который потребовал десятки лет просто, чтобы хотя бы начать широко применяться. http2 – это вовсе не IPv6. Это протокол, работающий поверх TCP, использующий обычный HTTP механизм обновления, номер порта, TLS и т. д. Он вообще не потребует замены большинства маршрутизаторов и брендмауеров.

Google доказал миру с помощью своей работы над SPDY, что такой новый протокол может быть внедрён и использован браузерами и сервисами с несколькими реализациями за довольно небольшой период времени. Несмотря на то, что количество серверов в Интернете, которые сегодня предлагают SPDY в районе 1%, но количество данных, с которыми они работают значительно больше. Некоторые из наиболее популярных веб-сайтов сегодня предлагают SPDY.

http2, основанный на тех же базовых парадигмах, что и SPDY, я уверен, вероятно будет внедрён ещё активнее, так как это официальный протокол IETF. Внедрение SPDY всегда сдерживалось клеймом «это протокол Google». 
За выпуском стоят несколько известных браузеров. По крайне мере представители Firefox, Chrome и Internet Explorer выразили готовность выпускать браузер с поддержкой http2.

Существуют и несколько серверных провайдеров, которые вероятно вскоре предложат http2, включая Google, Twitter и Facebook, и мы ожидаем увидеть поддержку http2 в популярных реализациях веб-серверов, таких как Apache HTTP Server и nginx.

http2 в Firefox


Firefox очень плотно отслеживает черновик спецификации и предоставляет поддержку тестовой http2 реализации уже многие месяцы. За время разработки протокола http2 клиенты и серверы должны договориться о том, какую версию черновика протокола они реализовали, что делает несколько раздражительным запуск тестов, просто будьте к этому готовы.

Сначала включите это

Введите «about:config» в адресной строке и ищите опцию, которая называется «network.http.spdy.enabled.http2draft». Убедитесь, что она установлена в true.

Только TLS


Помните, что Firefox реализовывает только http2 поверх TLS. Вы увидите работу http2 в Firefox, только когда перейдёте на https:// сайты, которые поддерживают http2.

Прозрачно!


Ни один элемент нигде в интерфейсе не скажет, что вы работаете по http2. Вы не сможете это так просто понять. Есть лишь один способ узнать это, включив «Веб-разработка->Сеть», проверить заголовки ответа и увидеть, что вы получили от сервера… Отклик содержит что-то о «HTTP/2.0» и Firefox вставляет свой заголовок с названием «X-Firefox-Spdy», как показано на этом, уже устаревшем скриншоте.
![](https://habrastorage.org/getpro/habr/post_images/b57/4d6/bec/b574d6becb3bd1d64276473c978c2ac5.png)
##HTTP/2 — это новая версия стандартного протокола передачи гипертекста. Протокол HTTP (Hypertext Transfer Protocol) является основой взаимодействия браузеров с веб-серверами, благодаря чему осуществляются загрузка и отображение веб-страниц. Первая версия, получившая название HTTP/0.9, появилась в 1991 году. Сегодня мы используем HTTP/1.1, который был представлен в 1999 году, после чего не получал обновления.

По мере развития сети загрузка веб-страниц требовала всё больше и больше ресурсов, поэтому потребовался новый протокол.

Как велась разработка
Новым протоколом занялся Инженерный совет интернета — организация, которая разрабатывает интернет-стандарты. Рабочая группа под названием HTTPbis была сформирована летом 2007 года. Обсуждение в группе новой версии HTTP протокола началось в конце 2012 года. За основу HTTP/2 был взят протокол SPDY (от speedy — быстрый), разработанный Google в 2009 году и интегрированный в Chrome, Internet Explorer и Firefox. Работа над HTTP/2 впоследствии началась с черновика SPDY/3.

Даниэль Штенберг, один из участников группы HTTPbis IETF, в апреле 2014 года опубликовал документ «Разъяснение HTTP/2», в котором подробно рассказал о причинах создания и ходе работы над проектом. Материал дополняется до сих пор. Там же он опубликовал концепцию, которую команда учитывала при разработке протокола:

Новая версия должна поддерживать парадигмы HTTP;
Ссылки http:// и https:// не могут быть изменены. Количество контента, которое использует подобную адресацию, слишком велико, чтобы когда-либо ожидать подобного изменения;
HTTP1 серверы и клиенты будут существовать ещё десятилетия;
Удалить или уменьшить число опциональных частей в протоколе;
Больше нет минорных версий. Клиенты и серверы могут быть либо совместимы с http2, либо нет.
Что изменилось
Главной целью обновления было повышение скорости загрузки страниц. Насколько она станет быстрее, ещё только предстоит узнать. Но Ноттингем предупреждает в своем блоге, что не стоит ожидать увеличения скорости на 50%. Он называет новый протокол скорее способом удалить некоторые ключевые препятствия на пути к большей производительности.

Главным приёмом, который поможет достичь этой цели, является мультиплексирование потоков. Штенберг объясняет принцип работы на простом примере: «Мультиплексирование потоков означает, что пакеты множества потоков смешаны в рамках одного соединения. Два (или больше) отдельных поезда данных собираются в один состав, а затем разделяются на другой стороне». То есть два «поезда», которые в текущей версии протокола «ехали» бы раздельно (и дольше), будут собираться вместе и отправляться по одному соединению в смешанном режиме.
##4.5.6.5 Протокол HTTP/2 (RFC-7540, Hypertext Transfer Protocol Version 2 (M. Belshe, R. Peon, M. Thomson, Ed.)
#Протокол Hypertext Transfer Protocol (HTTP) необыкновенно популярный протокол. Однако, то как HTTP/1.1 использует свой транспорт ([RFC7230], раздел 6) имеет несколько особенностей, которые негативно влияют на работу приложений.
В частности, HTTP/1.0 допускает только один исполняемый запрос для данного TCP-соединения. HTTP/1.1 добавил буферизацию запросов, но это только частично относится к одновременности запросов. Следовательно, клиенты HTTP/1.0 и HTTP/1.1, которым требуется несколько одновременных запросов, используют несколько соединений с сервером, чтобы обеспечить одновременность и уменьшить задержки.
Более того, поля заголовков HTTP часто дублируются, создавая избыточный сетевой трафик, а также быстрое заполнение исходного окна перегрузки TCP [TCP]. Это может вызвать дополнительную задержку при посылке дополнительных запросов через новое TCP-соединение.
HTTP/2 позволяет одновременную реализацию запросов и откликов через одно и то же соединение и использует эффективное кодирование для полей заголовка HTTP. Он также позволяет приоретизацию запросов, допуская для важных запросов более быстрое исполнение, что улучшает рабочие характеристики приложений.
Начало использования HTTP/2 придется на середину 2015 года, относительно широкое применение начнется в начале 2016 года.
Результирующий протокол является более дружественным для сети, так как можно использовать меньшее число TCP-соединений по сравнению с HTTP/1.x. Это понижает конкуренцию с другими потоками и длительными соединениями, что поднимает эффективность использования сетевых возможностей.
Наконец, HTTP/2 за счет размещения в кадрах двоичных сообщений делает обработку сообщений более эффективной.
2. Обзор протокола HTTP/2
Протокол HTTP/2 обеспечивает оптимизированный транспорт для семантики HTTP, он поддерживает все базовые возможности HTTP/1.1, но гарантирует большую эффективность.
Базовым модулем протокола HTTP/2 является кадр (раздел 4.1). Каждый тип кадра служит своей цели. Например, кадры HEADERS и DATA образуют основу запросов и откликов HTTP (раздел 8.1); другие кадры, например, WINDOW_UPDATE и PUSH_PROMISE используются для поддержки других функций HTTP/2.
Мультиплексирование запросов достигается за счет того, что каждый HTTP-обмен запрос-отклик ассоциируется со своим собственным потоком (раздел 5). Потоки по большей части являются независимыми, так блокировка или задержка реализации запроса или отклика не препятствует работе в других потоках.
Управление потоком и приоретизация гарантирует возможность эффективного мультиплексирования потоков. Управление потоком (раздел 5.2) помогает сделать так, что передаются только данные, которые нужны получателю. Приоретизация (раздел 5.3) гарантирует то, что ограниченные ресурсы направляются, прежде всего, для наиболее важных потоков.
HTTP/2 вводит новые режимы взаимодействия, за счет того, что сервер может продвигать отклики к клиенту (раздел 8.2). Процедура Server push позволяет серверу посылать данные клиенту, в предположении, что они ему нужны, проигрывая в эффективности использования сетевых ресурсов, но получая взамен снижение задержек отклика. Сервер делает это путем формирования запроса, который он посылает как кадр PUSH_PROMISE. Сервер может послать отклик на синтетический запрос через отдельный поток.
Так как поля заголовка HTTP, используемые для соединения, могут содержать большое количество избыточных данных, кадры, которые эти данные содержат, компрессируются (раздел 4.3). Это особенно удобно для стандартных запросов, позволяя помещать в пакет несколько запросов.
2.1. Организация документа
Спецификация HTTP/2 разделена на четыре части:
Запуск HTTP/2 (раздел 3) рассматривает то, как формируется HTTP/2 соединение.
Уровни кадров (раздел 4) и потоков (раздел 5) описывают методы структурирования кадров HTTP/2 и формирования мультиплексируемых потоков.
Определения кадров (раздел 6) и ошибок (раздел 7) включают информацию о кадрах и ошибках, используемых в HTTP/2.
HTTP мэпинг (раздел 8) и дополнительные требования (раздел 9) описывает то, как семантика HTTP характеризует кадры и потоки.
В то время как некоторые концепции уровня кадров и потоков независимы от HTTP, эта спецификация не определяет полностью уровень кадров.
2.2. Соглашения и терминология
Используются следующие термины:
Клиент:
Оконечная точка, которая инициирует HTTP/2 соединение. Клиенты посылают запросы HTTP и получают HTTP-отклики.
Соединение:
Соединение транспортного уровня между конечными точками.
Ошибка соединения:
Ошибка, которая воздействует на все HTTP/2 соединение.
Оконечная точка:
Клиент или сервер соединения.
Кадр:
Наименьший блок, передаваемый через соединение HTTP/2, состоящий из заголовка и последовательности октетов переменной длины, зависящей от типа кадра.
Партнер:
Оконечная точка. Когда обсуждается конкретная оконечная точка, "партнером" называется оконечная точка, которая является удаленной по отношению к обсуждаемому субъекту.
Получатель:
Оконечная точка, получающая кадры.
Отправитель:
Оконечная точка, передающая кадры.
Сервер:
Оконечная точка, которая воспринимает HTTP/2 соединение. Серверы получают запросы HTTP и формируют HTTP-отклики.
Поток:
Двунаправленный поток кадров через HTTP/2 соединение.
Ошибка потока:
Ошибка индивидуального потока HTTP/2.
Наконец, термины "шлюз", "промежуточный узел", "прокси", и "туннель" определены в разделе 2.3 [RFC7230]. Промежуточный узел в разное время работает как клиент или как сервер.
3. Запуск HTTP/2
Соединение HTTP/2 реализуется в рамках протокола прикладного уровня, работающего поверх TCP-соединения ([TCP]). Клиентом является инициатор TCP-соединения.
HTTP/2 использует ту же URI-схему, что "http" и "https", реализуемую в HTTP/1.1. HTTP/2 использует тот же номер порта по умолчанию: 80 для URI http и 443 для URI "https". В результате реализации для запросов типа http://example.org/foo или https://example.com/bar требуется выявление сначала того, поддерживает ли вышестоящий сервер (ближайший партнер, с которым клиент хочет установить соединение), HTTP/2.
Средства поддержки HTTP/2 для URI http и https различны. Выявление URI для "http" описано в разделе 3.2. Выявление URI для "https" URIs описано в разделе 3.3.
3.1. HTTP/2 Идентификация версии
Протокол, описанный в данном документе, имеет два идентификатора.
Строка "h2" идентифицирует протокол, где HTTP/2 использует TLS ["The Transport Layer Security (TLS) [TLS12]]. Этот идентификатор используется на уровне согласования поля расширения протокола TLS-приложения ALPN [TLS-ALPN] и определено для любого места, где идентифицирован HTTP/2 через TLS.
Строка "h2" объединяется с протокольным идентификатором ALPN в виде двухоктетной последовательности: 0x68, 0x32.
Строка "h2c" идентифицирует протокол, где HTTP/2 работает через TCP. Этот идентификатор используется в поле заголовка HTTP/1.1 Upgrade и в любом месте, где идентифицирован протокол HTTP/2 поверх TCP.
Строка "h2c" зарезервирована из пространства идентификаторов ALPN, но описывает протокол, который не использует TLS.
Согласование "h2" или "h2c" подразумевает использование семантики транспорта, безопасности, кадров и сообщений, описанных в данном документе.
3.2. Запуск HTTP/2 для URI "http"
Клиент, который посылает запрос URI "http" без предварительного знания о поддержке HTTP/2, следующим шагом использует механизм HTTP Upgrade (раздел 6.7 [RFC7230]). Клиент делает это путем посылки запроса HTTP/1.1, который включает поле заголовка Upgrade с лексемой "h2c". Такой HTTP/1.1 запрос должен включать только одно поле заголовка HTTP2-Settings (раздел 3.2.1).
Например:
GET / HTTP/1.1
     Host: server.example.com
     Connection: Upgrade, HTTP2-Settings
     Upgrade: h2c
     HTTP2-Settings: <base64url encoding of HTTP/2 SETTINGS payload>
Запросы, которые содержат поле данных, должны посылаться исключительно до того, как клиент сможет посылать кадры HTTP/2. Это означает, что большой запрос может блокировать использование соединения до завершения своей передачи.
Если важна одновременность исходного запроса с последующими запросами, может использоваться запрос OPTIONS для выполнения обновления до HTTP/2.
Сервер, который не поддержвает HTTP/2, может реагировать на запрос так, как будто заголовок Upgrade отсутствует:
HTTP/1.1 200 OK
     Content-Length: 243
     Content-Type: text/html
 
     ...
Сервер должен игнорировать строку "h2" в поле заголовка Upgrade. Присутствие строки "h2" подразумевает HTTP/2 через TLS, который согласуется, как это описано в разделе 3.3.
Сервер, который поддерживает HTTP/2, воспринимает upgrade с откликом 101 (Switching Protocols). После пустой строки, которая завершает отклик 101, сервер может начать посылку кадров HTTP/2. Эти кадры должны включать отклик на запрос, который запустил Upgrade.
Например:
HTTP/1.1 101 Switching Protocols
     Connection: Upgrade
     Upgrade: h2c
 
     [ HTTP/2 connection ...
Первый HTTP/2 кадр, посланный сервером, должен быть преамбулой соединения (раздел 3.5), состоящей из кадра SETTINGS (раздел 6.5). По получении отклика 101, клиент должен послать преамбулу соединения (раздел 3.5), которая содержит кадр SETTINGS.
Запрос HTTP/1.1, который послан раньше upgrade, приписывается идентификатору потока 1 (см. раздел 5.1.1) со значение приоритета по умолчанию (Раздел 5.3.5). Поток 1 является неявно полузакрытым ("half closed") для клиента по отношению к серверу (см. раздел 5.1), так как запрос завершен как HTTP/1.1 запрос. После инициализации соединения HTTP/2, поток 1 используется для откликов.
3.2.1 Поле заголовка HTTP2-Settings
Запрос, который обновляет HTTP/1.1 до HTTP/2, должен включать в себя одно поле заголовка "HTTP2-Settings". Поле заголовка "HTTP2-Settings" является полем заголовка специфическим для соединения, которое содержит параметры, управляющие соединением HTTP/2.
HTTP2-Settings = token68
Сервер не должен обновлять соединение до HTTP/2, если это поле заголовка отсутствует, или если присутствует более одного заголовка. Сервер не должен посылать это поле заголовка.
Содержимое поля заголовка "HTTP2-Settings" является полем данных кадра SETTINGS (раздел 6.5), закодированным как строка base64url (то есть, URL- и с именем файла, закодированным Base64, как описано в разделе 5 [RFC4648], с отброшенными завершающими символами '='). Процедура ABNF ["Augmented BNF для синтаксической спецификации: ABNF"] для "token68" определена в разделе 2.1 [RFC7235].
Так как обновление только готовится, клиент, посылающий "HTTP2-Settings", должен послать также "HTTP2-Settings", в качестве опции в поле заголовка "Connection", чтобы предотвратить переадресацию (см. раздел 6.1 [RFC7230]).
Сервер декодирует и интерпретирует эти значения, как для любого другого кадра SETTINGS. Явное подтверждение получения этих установок (раздел 6.5.3) не является обязательным, так как отклик 101 служит неявным подтверждением. Предоставление этих значений в запросе Upgrade дает клиенту возможность предоставить параметры до получения каких-либо кадров от сервера.
3.3. Введение HTTP/2 для "https" URI
Клиент, который делает запрос на URI "https", использует TLS ["The Transport Layer Security (TLS) Protocol Version 1.2" TLS12] с согласованием расширения протокола прикладного уровня ALPN (Application layer protocol negotiation) [TLS-ALPN].
HTTP/2 поверх TLS использует идентификатор протокола "h2". Идентификатор протокола "h2c" не должен посылаться клиентом или выбираться сервером; идентификатор протокола "h2c" описывает протокол, который не использует TLS.
Так как согласование TLS завершилось, как клиент, так и сервер должны послать преамбулу [preface] (раздел 3.5).
3.4. Начало HTTP/2 с предварительного знакомства
Клиент может узнать, что определенный сервер поддерживает HTTP/2 другим способом. Например, ["HTTP Alternative Services ALT-SVC] описывает механизм анонсирования таких возможностей.
Клиент должен послать преамбулу соединения (раздел 3.5), и затем может немедленно посылать кадры HTTP/2 серверу; серверы могут идентифицировать эти соединения за счет присутствия преамбулы соединения. Это влияет только на установление HTTP/2 соединения с использованием нешифрованного TCP; реализации, которые поддерживают HTTP/2 поверх TLS должны использовать протокол согласования в TLS [TLS-ALPN].
Аналогично, cервер должен послать преамбулу соединения (раздел 3.5).
3.5. Преамбула соединения HTTP/2
В HTTP/2, каждая из оконечных точек должна послать преамбулу соединения в качестве окончательного подтверждения использования протокола и установления начальных параметров для HTTP/2. Клиент и сервер посылают разные преамбулы соединения.
Преамбула соединения клиента начинается с последовательности из 24 октетов, которые в шестнадцатеричной нотации имеют вид:
0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
Т.е преамбула соединения начинается со строки "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n". За этой последовательностью должен следовать кадр SETTINGS (раздел 6.5), который может быть пустым. Клиент посылает преамбулу соединения сразу по получении отклика 101 Switching Protocols (индицируя успешное обновление), или после прихода первых информационных октетов TLS соединения. Если HTTP/2 соединение стартует при наличии информации о поддержке сервером протокола, преамбула соединения клиента посылается после установления соединения.
Преамбула соединения клиента выбирается так, чтобы для серверов и промежуточных узлов HTTP/1.1 или HTTP/1.0 исключить обработку последующих кадров.
Преамбула соединения сервера состоит из потенциально пустого кадра SETTINGS (раздел 6.5), который должен быть первым кадром, посылаемым сервером через соединение HTTP/2.
Кадры SETTINGS, полученные от партнера в качестве части преамбулы соединения, должны быть подтверждены (смотри раздел 6.5.3) после посылки преамбулы соединения.
Чтобы избежать ненужной задержки, клиентам разрешается посылка дополнительных кадров серверу сразу после посылки клиентом преамбулы соединения, не ожидая получения преамбулы сервера. Важно заметить, однако, что кадр SETTINGS преамбулы соединения сервера может содержать параметры, которые могут модифицировать протокол обмена с сервером. После получения кадра SETTINGS, клиент установит все необходимые параметры.
Клиенты и серверы должны рассматривать некорректную преамбулу соединения как ошибку соединения (раздел 5.4.1) типа PROTOCOL_ERROR. Кадр GOAWAY (раздел 6.8) может быть в этом случае опущен, так как индивидуальная преамбула указывает, что партнер не использует HTTP/2.
4. HTTP-кадры
Когда HTTP/2 соединение установлено, партнеры могут начать обмен кадрами.
4.1. Формат кадра
Все кадры начинаются с фиксированного 9-октетного заголовка, за которым следует поле данных переменной длины.

Рис. 1. Формат кадра
Длина: Длина поля данных, характеризуемая 24-разрядным целым числом без знака. Значения больше 214 (16,384) не должны пересылаться, если только получатель не установил большее значение для SETTINGS_MAX_FRAME_SIZE. 9 октетов заголовка сюда не включаются.
Тип: 8-битовый код типа кадра. Тип кадра определяет формат и семантику кадра. Реализации должны игнорировать и отбрасывать любые кадры с неизвестным типом.
Флаги: 8-битовое поле, зарезервированное для булевых флагов, характеризующих тип кадра.
Семантика присвоения флагов зависит от типа конкретного кадра. Флаги, которые не имеют определенной семантики для конкретного типа кадров, должны игнорироваться, и должны оставаться не установленными (0x0) при отправке.
R: Зарезервированное однобитовое поле. Семантика бита не определена и бит должен оставаться не установленным (0x0) при отправке и должен игнорироваться при получении.
Идентификатор потока:
Идентификатор потока (смотри раздел 5.1.1) представляет собой 31-битовое целое число без знака. Значение 0x0 зарезервировано для кадров, которые ассоциированы с соединением, в противоположность индивидуальному потоку.
Структура и содержимое поля данных кадра зависит полностью от типа кадра.
4.2 Размер кадра
Размер поля данных кадра ограничивается максимальным размером, который получатель анонсирует в SETTINGS_MAX_FRAME_SIZE. Это значение может лежать в диапазоне от 214 (16,384) до 224-1 (16.777.215) октетов включительно.
Все реализации должны быть способны получать и обрабатывать кадры длиной до 214 октетов, плюс 9 октетов заголовка кадра (раздел 4.1). Размер заголовка кадра не включается при указании размера кадра.
Замечание:
Определенные типы кадров, такие как PING (раздел 6.7), имеют дополнительные ограничения на размер поля данных.
Оконечная точка должна послать сообщение FRAME_SIZE_ERROR, если кадр превышает по размеру величину, определенную в SETTINGS_MAX_FRAME_SIZE, любой предел, определенный для кадра данного типа, или он слишком мал, чтобы содержать обязательные данные кадра. Ошибка размера кадра, который может изменить состояния всего соединения должна рассматриваться, как ошибка соединения (раздел 5.4.1); это относится к любому кадру, который содержит блочный заголовок (раздел 4.3) (то есть, HEADERS, PUSH_PROMISE и CONTINUATION), SETTINGS, и к любым кадрам с идентификатором потока 0.
Оконечные точки обязаны использовать все доступное пространство кадра. Реагирование может быть улучшено путем использования кадров, которые меньше чем допустимый максимальный размер. Посылка больших кадров может привести к задержкам времячувствительных кадров (таких как RST_STREAM, WINDOW_UPDATE или PRIORITY), которые в случае блокировки посылки больших кадров могут повлиять на рабочие характеристики системы.
4.3 Компрессия и декомпрессия заголовка
Точно также как и в HTTP/1, поле заголовка в HTTP/2 представляет собой имя с одним или более сопряженными значениями. Оно используется в HTTP-сообщениях запроса и отклика (смотри раздел 8.2). Смотри также RFC-7541 (HPACK: Header Compression for HTTP/2, R. Peon, H. Ruellan, 2015).
Списки заголовков представляют собой набор из нуля или более полей заголовка. При передаче через соединение, список заголовка формируется в блок заголовка, используя HTTP Header Compression [COMPRESSION]. Блок заголовка делится далее на последовательность из одного или более октетов, называемых фрагментами блока заголовка, передаваемых в поле данных кадров HEADERS (раздел 6.2), PUSH_PROMISE (раздел 6.6) или CONTINUATION (раздел 6.10).
Поле заголовка Cookie [COOKIE] обрабатывается системой HTTP-мэпинга (смотри раздел 8.1.2.5).
Принимающая сторона ответственна за объединение фрагментов заголовка, и последующую декомпрессию блока, для восстановления списка заголовка.
Полный блок заголовка состоит из:
одного HEADERS или кадра PUSH_PROMISE, с флагом END_HEADERS =1, или
HEADERS или кадра PUSH_PROMISE с флагом END_HEADERS =0 и одного или более кадров CONTINUATION, где последний кадр CONTINUATION имеет установленный флаг END_HEADERS.
Компрессия заголовка зависит от состояния. Для всего соединения используется один контекст компрессии и один контекст декомпрессии. Ошибка декодирования в блоке заголовка должна рассматриваться как ошибка соединения (раздел 5.4.1) типа COMPRESSION_ERROR.
Каждый блок заголовка обрабатывается как дискретный модуль. Блоки заголовка должны передаваться как непрерывная последовательность кадров, без чередования с какими-либо иными кадрами других типов или потоков. Последний кадр в последовательности кадров HEADERS или CONTINUATION имеет установленный флаг END_HEADERS. Последний кадр в последовательности кадров PUSH_PROMISE или CONTINUATION имеет установленный флаг END_HEADERS. Это позволяет блоку заголовка быть логически эквивалентным одному кадру.
Фрагменты блока заголовка могут быть посланы только как поле данных кадров HEADERS, PUSH_PROMISE или CONTINUATION, так как эти кадры несут в себе данные, которые могут модифицировать контекст компрессии, поддерживаемый получателем. Оконечная точка, получающая кадры HEADERS, PUSH_PROMISE или CONTINUATION, должна восстановить блоки заголовка и выполнить декомпрессию, даже если кадры должны быть отброшены. Получатель должен завершить соединение с ошибкой (раздел 5.4.1) типа COMPRESSION_ERROR, если он не декомпрессировал блок заголовка.
5. Потоки и мультиплексирование
"Поток" является независимой двунаправленной последовательностью кадров между клиентом и сервером в рамках HTTP/2 соединения. Потоки имеют несколько важных характеристик:
Одно соединение HTTP/2 может содержать одновременно несколько открытых потоков.
Потоки могут быть сформированы и использоваться односторонне клиентом или сервером.
Потоки могут быть закрыты любой из оконечных точек.
Порядок, в котором кадры посылаются в потоке существеннен. Получатели обрабатывают кадры в порядке их получения. В частности, порядок заголовков и полей данных является семантически значимым.
Потоки идентифицируются целыми числами. Идентификаторы потока приписываются потоку стороной, инициирующей поток.
5.1 Состояния потока
send: оконечная точка посылает этот кадр
recv: оконечная точка получает этот кадр
H: Заголовки кадра (с подразумеваемыми CONTINUATION)
PP: кадр PUSH_PROMISE (с подразумеваемыми CONTINUATION)
ES: флаг END_STREAM
R: кадр RST_STREAM
#Заметим, что эта диаграмма показывает переходы между состояниями, а также кадры и флаги, которые влияют на данный переход. В этом смысле, кадры CONTINUATION не вызывают смены состояния; они являются частью HEADERS или PUSH_PROMISE, за которыми следуют. Для целей смены состояния, флаг END_STREAM рассматривается как отдельное событие для кадра, где он размещен; кадр HEADERS с установленным флагом END_STREAM может вызвать переход из одного состояния в другое.
Обе оконечные точки имеют субъективное восприятие состояния потока, которое может отличаться при посылке кадров. Оконечные точки не координируют процессы формирования потоков; они создаются независимо каждой из сторон. Негативные последствия несоответствия состояний ограничено для состояния "closed" после посылки RST_STREAM, где кадры могут приходить некоторое время после закрытия.
Потоки имеют следующие состояния:
idle:
Все потоки начинаются из состояния "idle" (пассивен).
В этом состоянии разрешены следующие переходы:
Посылка или получение кадра HEADERS приводит к тому, что поток оказывается "open". Идентификатор потока выбирается так, как это описано в разделе 5.1.1. Тот же кадр HEADERS может также вынудить поток стать "полузакрытым".
Посылка кадра PUSH_PROMISE резервирует пассивный поток, который предполагается использовать позднее. Состояние резервированного потока - "зарезервировано (локально)".
Получение кадра PUSH_PROMISE другим потоком резервирует поток в пассивном состоянии для последующего использования. Состояние потока для переходов в состояние "зарезервировано (удаленно)".
Заметим, что кадр PUSH_PROMISE не посылается в рамках idle-потока, но создает ссылку на вновь зарезервированный поток в поле Promised Stream ID.
Получение любого кадра, отличного от HEADERS или PRIORITY для потока в этом состоянии должно рассматриваться, как ошибка соединения (раздел 5.4.1) типа PROTOCOL_ERROR.
reserved (локально):
Поток в состоянии "зарезервирован (локально)" создан путем посылки кадра PUSH_PROMISE. Кадр PUSH_PROMISE резервирует поток в пассивном состоянии, путем ассоциации потока с открытым потоком, который был инициирован удаленным партнером (смотри раздел 8.2).
В этом состоянии возможны только следующие переходы:
Оконечная точка может послать кадр HEADERS. Это вызывает переход потока в состояние "полузакрытый (удаленно)".
Любая оконечная точка может послать кадр RST_STREAM для перевода потока в состояние "closed". Это отменяет резервирование потока.
В этом состоянии оконечная точка не должна посылать какие-либо кадры, отличные от HEADERS, RST_STREAM или PRIORITY.
В этом состоянии может быть получен кадр PRIORITY или WINDOW_UPDATE. Получение любого кадра, отличного от RST_STREAM, PRIORITY или WINDOW_UPDATE в этом состоянии рассматривается как ошибка соединения (раздел 5.4.1) типа PROTOCOL_ERROR.
reserved (удаленно):
Поток в состоянии "reserved (удаленный)" зарезервирован удаленным партнером.
В этом состоянии допустимы только следующие переходы:
Получение кадра HEADERS вынуждает поток перейти в состояние "полузакрытый (локально)".
Любая из конечных точек может послать кадр RST_STREAM, для того чтобы поток перешел в состояние "closed".
В этом состоянии оконечная точка может послать кадр PRIORITY, чтобы реприоретизировать поток. Оконечная точка не должна посылать в этом состоянии какие-либо кадры, отличные от RST_STREAM, WINDOW_UPDATE или PRIORITY.
Получение любого кадра потока, отличного от HEADERS, RST_STREAM или PRIORITY в этом состоянии должно рассматриваться как ошибка соединения (раздел 5.4.1) типа PROTOCOL_ERROR.
open:
Поток в состоянии "open" может использоваться обоими партнерами для посылки кадров любого типа. В этом состоянии посылающие партнеры получают значения предельных параметров потока (раздел 5.2).
Из этого состояния любая оконечная точка может послать кадр с установленным флагом END_STREAM, который заставит поток перейти в одно из полузакрытых состояний: оконечная точка, посылая флаг END_STREAM, вызывает переход потока в состояние "полузакрытый (локально)"; оконечная точка, получив флаг END_STREAM, вызывает переход потока в состояние "полузакрытый (удаленно)".
Любая из оконечных точек в этом состоянии может послать кадры RST_STREAM, вызывая немедленный переход в состояние "closed" (закрыто).
полузакрытый (локально):
Поток, который является "полузакрытым (локально)", не может использоваться для пересылки кадров, отличных от WINDOW_UPDATE, PRIORITY и RST_STREAM.
Переходы потока из этого состояния в состояние "closed" (закрыто) возможно, когда приходит кадр, который содержит флаг END_STREAM, или когда любой из партнеров посылает кадр RST_STREAM.
Оконечная точка может получить в этом состоянии любой тип кадра. В этом состоянии получатель может игнорировать кадры WINDOW_UPDATE, которые могут прийти за короткий период после кадра с флагом END_STREAM.
Кадры PRIORITY, полученные в этом состоянии, используются для реприоретизации потоков, которые зависят от идентифицированного потока.
полузакрытый (удаленно):
Поток, который является "полузакрытым (удаленно)", не может более использоваться партнером для посылки пакетов. В этом состоянии оконечная точка не обязана более поддерживать управляющее окно входного потока.
Если оконечная точка получает дополнительные кадры для потока, который находится в состоянии, отличном от WINDOW_UPDATE, PRIORITY или RST_STREAM, она должна откликнуться сигналом ошибки потока (раздел 5.4.2) типа STREAM_CLOSED.
Поток, который является "полузакрытым (удаленно)", может использоваться оконечной точкой для посылки кадров любого типа. В этом состоянии оконечная точка продолжает отслеживать анонсированный уровень пределов управления потоком (раздел 5.2).
Поток может перейти из этого состояния в состояние "закрыто" путем посылки кадра, который содержит флаг END_STREAM, или когда любой из партнеров посылает кадр RST_STREAM.
closed:
Состояние "closed" является терминальным состоянием.
Оконечная точка не должна посылать кадры, отличные от PRIORITY, для закрытых потоков. Оконечная точка, которая получает любой кадр, отличный от PRIORITY, после получения RST_STREAM, должна рассматривать его как ошибку потока (раздел 5.4.2) типа STREAM_CLOSED. Аналогично, оконечная точка, которая получает любые кадры после получения кадра с флагом END_STREAM, должна рассматривать это как ошибку соединения (раздел 5.4.1) типа STREAM_CLOSED, если только такой кадр не разрешен, как это описано ниже.
В этом состоянии могут быть получены кадры WINDOW_UPDATE или RST_STREAM вскоре после посылки кадра DATA или HEADERS, содержащего флаг END_STREAM. До тех пор пока удаленный партнер получает и обрабатывает RST_STREAM или кадр, содержащий флаг END_STREAM, он может посылать кадры этого типа. Оконечные точки должны игнорировать кадры WINDOW_UPDATE или RST_STREAM, полученные в этом состоянии, хотя оконечные точки могут решить воспринимать кадры, которые приходят много позже посылки END_STREAM, как ошибку соединения (раздел 5.4.1) типа PROTOCOL_ERROR.
Кадры PRIORITY могут посылаться в закрытые потоки, чтобы приоретизировать потоки, которые являются зависимыми от закрытого потока. Оконечные точки должны обрабатывать кадры PRIORITY, хотя они могут игнорироваться, если поток был удален из дерева зависимостей (смотри раздел 5.3.4).
Если это состояние получено в результате посылки кадра RST_STREAM, партнер, который получает RST_STREAM может быть уже послал - или получил для посылки - кадры, которые не могут быть отозваны. Оконечная точка должна игнорировать кадры, которые поучены при закрытых потоках после того как послан кадр RST_STREAM. Оконечная точка может выбрать значение времени, в течение которого она игнорирует кадры и рассматривает кадры, пришедшие после этого времени, как ошибку.
Кадры, управляемые потоком (т.е., DATA) и полученные после отправки RST_STREAM нумеруются в рамках окна управления потоком. Даже если кадры могли игнорироваться, так как они посланы до получения отправителем RST_STREAM, отправитель будет считать эти кадры в пределах окна управления потоком.
Оконечная точка может получить кадр PUSH_PROMISE после того как пошлет RST_STREAM. PUSH_PROMISE вынуждает поток перейти в состояние "зарезервировано", даже если соответствующий поток был сброшен. Следовательно, RST_STREAM нужен для закрытия нежелательного promised потока.
Реализации должны рассматривать получение кадра, который не допустим в текущем состоянии, как ошибку соединения (раздел 5.4.1) типа PROTOCOL_ERROR. Заметим, что PRIORITY может быть послан и получен в любом состоянии потока. Кадры неизвестного типа игнорируются.
5.1.1 Идентификаторы потока
Потоки идентифицируются с помощью 31-битных целых чисел без знака. Потоки, инициированные клиентом, должны использовать нечетные идентификаторы потока; потоки, инициированные сервером должны использовать четные идентификаторы потока. Идентификатор потока (0x0) используется для сообщений управления соединением; нулевой идентификатор потока не может быть использован для инициации нового потока.
HTTP/1.1 запросы, которые обновлены до HTTP/2 (смотри раздел 3.2) ставятся в соответсвие с идентификатором потока (0x1). После завершения обновления поток 0x1 является для клиента "полузакрытым (локально)". Следовательно, номер 0x1 не может быть выбран клиентом в качестве нового идентификатора потока.
Идентификатор вновь установленного потока должен быть численно больше, чем для всех потоков, созданных или зарезервированных данной оконечной точкой. Это относится к потокам открытым с помощью кадра HEADERS и к потокам, которые зарезервированы с помощью PUSH_PROMISE. Оконечная точка, которая получает неизвестный идентификатор потока, должна реагировать сигналом ошибки соединения (раздел 5.4.1) типа PROTOCOL_ERROR.
Первое использование нового идентификатора потока закрывает все потоки с состоянием "idle", которые могли быть инициированы данным партнером с идентификаторами потока, имеющими меньшие значения. Например, если клиент посылает кадр HEADERS в поток 7, не посылая кадр в поток 5, тогда поток 5 переходит в состояние "closed" , когда первый кадр потока 7 оказывается послан и получен.
Идентификаторы потока не могут быть повторно использованы. Долгоживущие соединения могут вызвать исчерпание доступных идентификаторов потока у данной оконечной точки. Клиент, который может установить новый идентификатор потока, может сформировать новое соединение для новых потоков. Сервер, который не может задать новый идентификатор потока, может послать кадр GOAWAY, так что клиент будет вынужден открыть новое соединение для новых потоков.
5.1.2 Одновременность потоков
Партнер может ограничить число одновременно активных потоков, используя параметр SETTINGS_MAX_CONCURRENT_STREAMS (смотри раздел 6.5.2) в кадре SETTINGS. Максимальное число одновременных потоков является специфическим для каждой оконечной точки и применимо только для партнера, получившего эту установку. То есть, клиент специфицирует максимальное число одновременных потоков, инициируемых сервером, а серверы специфицируют максимальное число одновременных потоков, инициируемых клиентом.
Потоки, которые находятся в открытом состоянии ("open"), или в любом из "полузакрытых" состояний нумеруются вплоть до максимального числа потоков, позволенных открыть оконечной точке. Потоки в любом из этих трех состояний нумеруются в направлении предела, указанного в SETTINGS_MAX_CONCURRENT_STREAMS. Потоки в любом из резервированных состояний не нумеруются до предельного значения потоков.
Оконечные точки не должны превышать предел, установленный партнером. Оконечная точка, получающая кадр HEADERS, который вызывает превышение предела для ее анонсированного числа одновременных потоков, должна рассматривать это, как ошибку потока (раздел 5.4.2) типа PROTOCOL_ERROR или REFUSED_STREAM. Выбор ошибки кода определяется тем, хочет ли оконечная точка допускать автоматическое повторение попытки, подробности смотри в разделе 8.1.4).
Оконечная точка, которая хочет уменьшить значение SETTINGS_MAX_CONCURRENT_STREAMS до величины, которая меньше номера текущего потока, может либо закрыть потоки, с идентификаторами, превышающими новое значение предела или позволить потокам завершиться.
5.2 Управления потоком
Использование потоков для мультиплексирования порождает противоречие при использовании TCP-соединения для блокированных потоков. Схема управления потоком гарантирует то, что потоки одного и того же соединения не будут деструктивно взаимодействовать друг с другом. Управление потоком используется как для отдельных потоков, так и для соединения в целом.
HTTP/2 осуществляет управление потоком за счет использования кадра WINDOW_UPDATE (раздел 6.9).
5.2.1 Принципы управления потоком
Управление потоком HTTP/2 имеет целью обеспечение различных алгоритмов управления потоком без изменения протокола. Управление потоком в HTTP/2 имеет следующие характеристики:
Управление потоком является специфическим для соединения. Оба типа управления потоком между оконечными точками канального сегмента (hop), а не через весь маршрут из конца в конец.
Управление потоком базируется на кадрах обновления окна. Получатели анонсируют, сколько октетов они готовы получить для текущего потока и для соединения в целом. Эта схема базируется на доверии.
Управление потоком работает с учетом направления с и обеспечивается получателем. Получатель может выбрать любой размер окна, которые он хочет иметь для каждого потока и для всего соединения. Отправитель должен учитывать пределы управления потоком, установленные получателем. Клиенты, серверы и промежуточные узлы независимо анонсируют свои окна управления потоком как получатели и ожидают значений пределов управления, установленных их партнерами при отправлении пакетов.
Исходное значение для окна управления потоком равно 65,535 октетов для новых потоков и для соединения в целом.
Тип кадра определяет, относится ли управление потоком к кадру. Для кадров, специфицированных в данном RFC, только кадры DATA являются объектами управления потоком; все другие типы кадров не будут занимать места в анонсированном окне управления потоком. Это гарантирует, что важные для управления кадры не будут заблокированы системой управления потока.
Управление потоком не может быть запрещено.
HTTP/2 определяет только формат и семантику кадра WINDOW_UPDATE (раздел 6.9). Данное RFC не оговаривает, как получатель решает, когда посылать этот кадр или значения, которые он несет, здесь не специфицируется, как отправитель выбирает пакеты для отправки. Реализации могут выбрать любой алгоритм, который подходит для их нужд.
Реализации ответственны также за то, как следует посылать запросы и отклики с учетом их приоритета; как избежать блокировки запросов; и управлять формированием новых потоков. Алгоритмы этих выборов могут интерферировать с любыми алгоритмами управления потоком.
5.2.2 Правильное использование управления потоками
Управление потоком предназначено для того, чтобы оконечные точки работали с учетом имеющихся ресурсных ограничений. Например, прокси должны распределять память между многими соединениями, а также работать с медленным исходящим и быстрым входящим потоками. Управление потоком относится к случаям, когда получатель не может обработать данные одного потока, но хочет обрабатывать другие потоки данного соединения.
В ситуациях, которые не требуют этого, можно анонсировать окно управления потока максимального размера (231-1), и сохранять это окно при посылке кадра WINDOW_UPDATE при получении любых данных. Это эффективно исключает управление потоком для этого получателя. Напротив, отправитель всегда зависит от окна управления потоком, анонсированного получателем.
Задачи с ограниченными ресурсами (например, памятью) могут использовать управление потоком, чтобы ограничить размер требуемой памяти до уровня, приемлемого для партнера. Заметим, однако, что это может привести к неоптимальному использованию имеющихся сетевых ресурсов, если управление потоком функционирует при неизвестном произведении полосы на RTT (смотри [RFC7323]).
Но даже при знании произведения полосы на RTT, реализация управления потоком может быть затруднена. Когда при использовании управления потоком получатель должен считать данные из входного TCP-буфера в оговоренный момент времени. Невозможность выполнить это может привести к проблемам, когда критические кадры, такие как WINDOW_UPDATE, не могут быть считаны.
5.3 Приоритет потока
Клиент может присвоить приоритет новому потоку путем включения приоритетной информации в кадр HEADERS (раздел 6.2), который открывает поток. В любое другое время, кадр PRIORITY (раздел 6.3) может использоваться для изменения приоритета потока.
Целью приоретизации является предоставление возможности оконечной точке определить, как она предпочитает распределить ресурсы для обслуживания одновременных процессов. Приоритет может использоваться при выборе потоков для передачи кадров в условиях ограниченных возможностей передачи.
Потоки могут быть приоретизированы, помечая их зависимыми от завершения других потоков (раздел 5.3.1). Каждой зависимости приписывается относительный вес, число, которое используется для определения относительной доли доступного ресурса, который присвоен данному потоку.
Явное присвоение приоритета потоку является началом процесса приоретизации. Это не гарантирует определенного порядка обработки или пересылки для данного потока по отношению к другим потокам. Оконечная точка не может заставить партнера обрабатывать одновременные потоки в определенном порядке с учетом приоритета.
Информация приоретизации в сообщении может быть опущена. До того как какой-либо приоритет будет задан, используются значения по умолчанию (раздел 5.3.5).
5.3.1 Зависимости потоков
Каждому потоку может быть присвоена определенная зависимость от другого потока. Включение зависимости выражает предпочтения при выделении ресурсов определенному потоку.
Поток, который не зависит ни от какого другого потока, получает значение зависимости 0x0. Другими словами, несуществующий поток 0 образует корень дерева.
Поток, который зависит от другого потока, является зависимым потоком. Поток, от которого поток зависит, является родительским потоком. Зависимость от потока, который не входит в дерево зависимостей - такой как поток в состоянии "idle" - приводит к тому, что потоку присваивается приоритет по умолчанию (раздел 5.3.5).
При установлении зависимости от другого потока, поток добавляется в качестве новой зависимости родительского потока. Зависимые потоки, которые имеют общего прародителя остаются неупорядоченными по отношению друг к другу. Например, если потоки B и C являются зависимыми от потока А, и, если поток D создан зависимым от потока A, это приводит в результате к порядку зависимости потока A, за которым следуют B, C, и D в любом порядке.
#5.5 Расширение HTTP/2
HTTP/2 допускает расширение протокола. Расширения протокола могут использоваться для реализации дополнительных сервисов или модификации протокола, в пределах ограничений рассмотренных в данном разделе. Расширения эффективны только в пределах одного HTTP/2 соединения.
Это относится к элементам протокола, определенным в данном документе. Это не распространяется на существующие опции для HTTP, такие как определения методов, статусных кодов или полей заголовка.
Расширения допускают использование новых типов кадров (раздел 4.1), новых установок (раздел 6.5.2), или новых кодов ошибок (раздел 7). Расширения по указанным темам можно найти в разделах: типы кадров (раздел 11.2), установки (раздел 11.3) и коды ошибок (раздел 11.4).
Реализации должны игнорировать неизвестные и неподдерживаемые значения всех расширяемых элементов протокола. Реализации должны отбрасывать кадры неизвестного и неподдерживаемого типа. Это означает что кадры расширения, которые появляются в середине блока заголовка (раздел 4.3) недопустимы; они должны рассматриваться как ошибка соединения (раздел 5.4.1) типа PROTOCOL_ERROR.
Расширения, которые могут изменить семантику компонентов существующего протокола должны быть согласованы до начала использования. Например, расширение, которое изменяет структуру кадра HEADERS, не может быть использовано до согласования с партнером. В этом случае может быть также необходимо координировать момент, когда такая модификация вступает в силу.
6. Определения кадра
Ниже определено несколько типов кадров, каждый из которых идентифицируется уникальным 8-битовым кодом типа. Каждый тип кадра предназначен для определенной цели при установлении соединения или для его управления.
Передача специфических типов кадра может изменить состояние соединения. Если оконечным точкам не удается поддерживать идентичное представление о состоянии соединения, успешное использование соединения не будет возможно. Следовательно, важно, чтобы оконечные точки имели общее представление о влиянии на состояние соединения тех или иных кадров.
