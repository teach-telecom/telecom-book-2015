##Введение 
      В настоящее время наблюдается тенденция к переносу большого количества приложений в среду Интернет
     – это позволяет более эффективно организовывать совместную работу с данными, коммуникацию удаленных
     пользователей и быстрое реагирование на возникающие события. Распределенные приложения, доступ к 
     которым осуществляется посредством линий связи, оказались очень удобными – появилась возможность 
     разделять места хранения данных и эффективно организовывать доступ к ним персонала из любой точки 
     земного шара. Разумеется, активное использование распределенных веб-приложений накладывает крайне 
     высокие требования на платформу, на которой происходит их выполнение – должна обеспечиваться надежная
     и бесперебойная работа серверов, высокая скорость доступа и возможность динамического обновления 
     программного обеспечения на серверных компьютерах. 
      В последние несколько лет все большую популярность приобретают серверы, работающий под управлением
     операционных систем семейства UNIX: FreeBSD, OpenBSD, Solaris, Linux. Все эти системы спроектированы
     в соответствии со стандартом POSIX и имеют идентичный программный интерфейс, что позволило с легкостью
     переносить приложения, написанные в одной системе, на другую. Кроме того, все эти системы показали 
     себя крайне надежными и отказоустойчивыми, по большей части из-за постоянного совершенствования, которое,
     зачастую, выполняется бесплатно энтузиастами со всего мира.
      С появлением большого числа серверов под управлением операционных систем семейства UNIX встал вопрос
     об администрировании этих серверов и, в частности, производить административные действия удаленно,
     посредством сетей передачи данных. Необходимость подобных действий вызвана тем, что физически сервер
     не всегда может быть доступен: администратор может обслуживать сразу несколько серверов, физически 
     отстоящих друг от друга на значительное расстояние, что не позволяет получить непосредственный доступ 
     к каждой машине; также администратор не может находиться на рабочем месте постоянно, тогда как неполадки
     могут возникнуть в любой момент. Кроме того, серверные компьютеры, к которым предъявляются повышенные 
     требования надежности и безопасности, часто располагают в закрытых помещениях, доступ в которые разрешен
     только специальному обслуживающему персоналу. Все это привело к созданию ряда программных средств, служащих
     одной цели – возможности осуществлять удаленное администрирование компьютера.
      Одним из первых появился программный продукт под названием telnet. Он состоял из клиентской и серверной 
     частей и позволял клиентской части подключаться к серверной, находящейся на удаленном компьютере. После
     этого пользователь получал в свое распоряжение так называемый виртуальный терминал – он мог набирать
     стандартные команды UNIX, которые затем транслировались через сеть на удаленный компьютер telnet-серверу,
     выполнялись, а результаты выполнения передавались обратно на клиентскую машину. Таким образом, 
     осуществлялась удаленная работа с компьютером, аналогичная по функциональности непосредственному доступу.
      Основной проблемой данной программной системы являлась безопасность доступа. Авторизация пользователя 
     осуществлялась стандартными средствами UNIX, что приводило к передачи по сетям в открытом виде информации
     об учетных записях системы. Эта информация, в свою очередь, могла быть перехвачена злоумышленниками и  
     использована в целях вывода системы из строя или получения над ней полного контроля.
      Следующим шагом стало создание так называемой защищенной оболочки (secureshell или, сокращенно, ssh).
     Этот программный комплекс по своей структуре был похож на telnet – также выделялись клиентская и серверная
     часть и пользователь получал в свое распоряжение виртуальный терминал при подключении. Однако в данном 
     случае при авторизации пользователя использовались уже не стандартные ученые записи UNIX, а собственная 
     база данных пользователей, информация о которых передавалась в зашифрованном виде. Шифровались также и 
     команды, передаваемые на сервер, и ответная информация. Все это сделало удаленное администрирование 
     достаточно безопасным и привело к росту популярности ssh.
##Протоколы передачи данных
      Протоколом передачи данных называется ряд правил и утверждений, предназначенных для создания 
     унифицированного интерфейса между взаимодействующим программным обеспечением. Это позволяет 
     разрабатывать приложения, взаимодействие между которыми определяется не операционной системой,
     под управлением которой они работают, а протоколами, учтенными при разработке.
      Все современные протоколы передачи данных классифицированы организацией ISO на уровни, в результате
     чего появилось понятие модели OSI (opensystemsinterconnection – соединение открытых систем). Согласно
     этой модели, существует семь уровней рассмотрения передачи данных:
     1. Физический (physical) – представлен линиями связи и коммуникационным оборудованием.
     2. Связи (datalink) – представлен драйверами сетевого оборудования и программным обеспечением
     нижнего уровня.
     3. Сетевой (network) – представлен протоколами IPv4 и IPv6.
     4. Транспортный (transport) – представлен протоколами транспортного уровня, такими как TCP, UDP,
     ICMP и другими.
     5. Сеансовый (session) – представлен программными средствами, поддерживающими сеансы связи.
     6. Представления данных (presentation) – представлен программными средствами, обеспечивающими
     независимость интерпретации данных от используемой системы.
     7. Прикладной (application) – представлен множеством протоколов, направленных на передачу определенных
     данных – файлов, гипертекстовых документов и т.д. К этим протоколам относятся HTTP, FTP, SMTP и др.
     
##Протокол HTTP
      Протокол HTTP (HyperTextTransferProtocol – протокол передачи гипертекста) – это протокол уровня
     приложения, осуществляющий связь приложений в пределах распределенных, совместных или разнородных
     информационных систем. Протокол позволяет приложениям обмениваться данными, представленными в 
     понятном для восприятия человеком виде. 
      Как следует из его названия, первоначально HTTP предназначался для передачи между приложениями так
     называемого гипертекста (hypertext), представляющего собой особый вид данных, созданный в 
     соответствии со стандартом HTML (HyperTextMarkupLanguage – язык разметки гипертекста). Гипертекстовый
     документ состоит из данных, размеченных с помощью тегов (tag) языка HTML, и представляет собой 
     комбинацию текста, изображений, гиперссылок и прочих средств представления данных. Гиперссылки – одна
     из важнейших составляющих HTML-документа – представляют собой интерактивные области, воздействие на 
     которые приводит к получению связанных с гиперссылкой данных. Это позволяет пользователю, работающему
     с гипертекстовой информацией, осуществлять навигацию в пределах набора документов или даже всей сети
     Интернет, получая интересующую его информацию с помощью контекстных гиперссылок.
      Протокол HTTP является надстройкой над протоколом TCP и является средством контроля содержания 
     передаваемых данных. В отличие от TCP, который не учитывал структуру передаваемых пакетов, HTTP 
     внедряет в данные метаинформацию, позволяющую получателю корректно интерпретировать полученные данные.
     На основе HTTP функционирует глобальная сеть Интернет (называемая также WorldWideWeb или WWW). Первая
     версия протокола – HTTP/0.9 – обладала достаточно ограниченными возможностями, но с активным развитием
     всемирной сети появились новые версии: HTTP/1.0 и HTTP/1.1, позволяющие контролировать передачу по 
     вычислительным сетям не только гипертекстовой информации, но и произвольные бинарные файлы: звуковые,
     графические, архивные и пр.
      В силу того, что HTTP является надстройкой над протоколом TCP, при передачи данных также выделяются
     две стороны: клиент и сервер. 
      Клиент является инициатором соединения и запрашивает у сервера некоторые данные или услуги. Клиентом,
     как правило, является программа, называемая браузером (browser), позволяющая как отображать 
     гипертекстовую информацию, так и принимать файлы иных форматов. Чтобы получить некоторую интересующую
     информацию, клиент посылает серверу запрос (request), содержащий описание запрашиваемой информации.
      Сервер при передаче данных через HTTP называют веб-сервером (web-server). Эта программа осуществляет
     обработку запросов от клиентов, передавая запрошенные данные в виде ответов (response), содержащих 
     помимо искомых данных метаинформацию, их описывающую.
      Получение пользователем интересующих его данных состоит из следующих этапов:
     1. Пользователь вводит в строке браузера адрес интересующего его ресурса.
     2. Браузер на основе информации, полученной от пользователя, а также учитывая свои настройки и 
     конфигурацию операционной системы, формирует запрос.
     3. Браузер подключается к серверу, расположенном, возможно, на удаленном компьютере, и передае
     т ему запрос.
     4. Сервер, анализируя запрос, выполняет необходимые действия: формирует ответ, включая в него 
     тело запрошенного документа. Если это гипертекстовый документ, он загружается из файла или же 
     генерируется динамически посредством сценария. В ответ также включается информация о содержащихся
     в нем данных.
     5. Сервер передает ответ браузеру.
     6. Браузер анализирует ответ и либо сохраняет полученные данные в файл, либо, в случае 
     гипертекстового документа, анализирует теги HTML и отображает документ на экране.
      Следует заметить, что клиентской программой может быть не только браузер, тем не менее, все шаги,
     за исключением, может быть, первого, выполняются в любом случае.
      Следует заметить, что здесь рассматривается непосредственное подключение клиента к серверу, 
     содержащему интересующую информацию, однако, это не всегда возможно в силу различных обстоятельств.
     В таком случае подключение может осуществляться посредством одной или более промежуточных точек
     подключения. Можно разделить эти промежуточные точки на три группы:
     • Прокси-серверы (proxy-server) – программа-посредник, выполняющая функции как клиента, так и 
     сервера с целью создания запросов от имени других клиентов. Запросы обслуживаются прокси-сервером,
     или пересылаются им с внесением в них изменений (в этом случае прокси-сервер называется непрозрачным)
     или без изменений (в этом случае прокси-сервер называется прозрачным). Прокси-сервер позволяет 
     группе компьютеров выступать в качестве одного клиента, что часто применяется при подключении к 
     Интернету локальных сетей.
     • Шлюз (gateway) – как и прокси-сервер, осуществляет трансляцию запросов, однако, не подвергаю их
     изменению. Шлюз получает от клиента запрос, как к серверу, содержащему искомый ресурс. Таким образом,
     клиент не может определить, подключается ли он через шлюз или непосредственно к содержащему ресурс серверу.
     • Туннель (tunnel) – программа-посредник, поддерживающая соединение. Хотя после установки соединения
     туннель не рассматривается в качестве элемента передачи через протокол HTTP, соединение, как правило,
     инициируется именно HTTP-запросом. Туннель прерывает свою работу, если хотя бы один из участников обмена
     данными закрывает соединение. 
      Для сохранения функциональности передачи данных при подключении через промежуточные точки не требуется 
     внесения изменений в запросы и ответы, за исключением случая прокси-сервера: в этом случае в клиентском
     запросе должны содержаться дополнительные поля. Однако, с точки зрения сервера, обмен данными 
     производится непосредственно с клиентом, следовательно, никаких изменений в запросах не происходит. 
      Запрос, отправляемый клиентом серверу, служит для точной идентификации запрашиваемого ресурса, а 
     также содержит сведения, необходимые для корректной обработки запроса.
##Структура протокола
     По своей структуре запрос состоит из трех частей:
     • Стартовая строка (англ. Starting line) — определяет тип сообщения;
     • Заголовки (англ. Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения;
     • Тело сообщения (англ. Message Body) — непосредственно данные сообщения. Обязательно должно отделяться
     от заголовков пустой строкой.
      Заголовки и тело сообщения могут отсутствовать, но стартовая строка является обязательным элементом,
     так как указывает на тип запроса/ответа. Исключением является версия 0.9 протокола, у которой сообщение
     запроса содержит только стартовую строку, а сообщения ответа только тело сообщения.
##Стартовая строка
      Стартовая строка состоит из трех полей, разделенных символами пробела (ASCII-код 20h, далее SP),
     и заканчивается комбинацией из двух символов: возврат каретки (ASCII-код 0Dh, далее CR) и перевод
     строки (ASCII-код 0Ah, далее LF). Элементы строки запроса представлены следующими полями:
      Стартовые строки различаются для запроса и ответа. Строка запроса выглядит так:
      GET URI — для версии протокола 0.9.
      Метод URI HTTP/Версия — для остальных версий.
     Здесь:
     •	Метод (англ. Method) — название запроса, одно слово заглавными буквами. В версии HTTP 0.9
     использовался только метод GET, список запросов для версии 1.1 представлен ниже.
     •	URI определяет путь к запрашиваемому документу.
     •	Версия (англ. Version) — пара разделённых точкой цифр. Например: 1.0
      Чтобы запросить страницу данной статьи, клиент должен передать строку (задан всего один заголовок):
     GET /wiki/HTTP HTTP/1.0
     Host: ru.wikipedia.org

      Стартовая строка ответа сервера имеет следующий формат: HTTP/Версия КодСостояния Пояснение, где:
     •	Версия — пара разделённых точкой цифр как в запросе.
     •	Код состояния (англ. Status Code) — три цифры. По коду состояния определяется дальнейшее содержимое
     сообщения и поведение клиента.
     •	Пояснение (англ. Reason Phrase) — текстовое короткое пояснение к коду ответа для пользователя.
     Никак не влияет на сообщение и является необязательным.
      Например, стартовая строка ответа сервера на предыдущий запрос может выглядеть так:
     HTTP/1.0 200 OK
##Методы
      Метод HTTP (англ. HTTP Method) — последовательность из любых символов, кроме управляющих и разделителей,
     указывающая на основную операцию над ресурсом. Обычно метод представляет собой короткое английское слово,
     записанное заглавными буквами. Обратите внимание, что название метода чувствительно к регистру.
      Каждый сервер обязан поддерживать как минимум методы GET и HEAD. Если сервер не распознал указанный
     клиентом метод, то он должен вернуть статус 501 (Not Implemented). Если серверу метод известен, но он 
     неприменим к конкретному ресурсу, то возвращается сообщение с кодом 405 (Method Not Allowed). В обоих 
     случаях серверу следует включить в сообщение ответа заголовок Allow со списком поддерживаемых методов.
      Кроме методов GET и HEAD, часто применяется метод POST.
######OPTIONS
      Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса.
     В ответ серверу следует включить заголовок Allow со списком поддерживаемых методов. Также в заголовке
     ответа может включаться информация о поддерживаемых расширениях.
      Предполагается, что запрос клиента может содержать тело сообщения для указания интересующих его сведений.
     Формат тела и порядок работы с ним в настоящий момент не определён. Сервер пока должен его игнорировать.
     Аналогичная ситуация и с телом в ответе сервера.
      Для того, чтобы узнать возможности всего сервера, клиент должен указать в URI звёздочку — «*». Запросы
     «OPTIONS * HTTP/1.1» могут также применяться для проверки работоспособности сервера (аналогично 
     «пингованию») и тестирования на предмет поддержки сервером протокола HTTP версии 1.1.
      Результат выполнения этого метода не кэшируется.
######GET
      Используется для запроса содержимого указанного ресурса. С помощью метода GET можно также начать
     какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе 
     выполнения процесса.
      Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «?»:
      GET /path/resource?param1=value1&param2=value2 HTTP/1.1
      Согласно стандарту HTTP, запросы типа GET считаются идемпотентными.
      Кроме обычного метода GET, различают ещё условный GET и частичный GET. Условные запросы GET содержат
     заголовки If-Modified-Since, If-Match, If-Range и подобные. Частичные GET содержат в запросе Range.
     Порядок выполнения подобных запросов определён стандартами отдельно.
######HEAD
      Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело. Запрос HEAD обычно
     применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, 
     не изменился ли он с момента последнего обращения.
      Заголовки ответа могут кэшироваться. При несовпадении метаданных ресурса с соответствующей информацией
     в кэше копия ресурса помечается как устаревшая.
######POST
      Применяется для передачи пользовательских данных заданному ресурсу. Например, в блогах посетители обычно
     могут вводить свои комментарии к записям в HTML-форму, после чего они передаются серверу методом POST
     и он помещает их на страницу. При этом передаваемые данные (в примере с блогами — текст комментария) 
     включаются в тело запроса. Аналогично с помощью метода POST обычно загружаются файлы на сервер.
      В отличие от метода GET, метод POST не считается идемпотентным[4], то есть многократное повторение одних
     и тех же запросов POST может возвращать разные результаты (например, после каждой отправки комментария 
     будет появляться очередная копия этого комментария).
      При результате выполнения 200 (Ok) в тело ответа следует включить сообщение об итоге выполнения запроса.
     Если был создан ресурс, то серверу следует вернуть ответ 201 (Created) с указанием URI нового ресурса в
     заголовке Location.
      Сообщение ответа сервера на выполнение метода POST не кэшируется.
######PUT
      Применяется для загрузки содержимого запроса на указанный в запросе URI. Если по заданному URI не
     существует ресурс, то сервер создаёт его и возвращает статус 201 (Created). Если же был изменён ресурс,
     то сервер возвращает 200 (Ok) или 204 (No Content). Сервер не должен игнорировать некорректные заголовки
     Content-*, передаваемые клиентом вместе с сообщением. Если какой-то из этих заголовков не может быть 
     распознан или не допустим при текущих условиях, то необходимо вернуть код ошибки 501 (Not Implemented).
      Фундаментальное различие методов POST и PUT заключается в понимании предназначений URI ресурсов. Метод
     POST предполагает, что по указанному URI будет производиться обработка передаваемого клиентом 
     содержимого. Используя PUT, клиент предполагает, что загружаемое содержимое соответствует находящемуся 
     по данному URI ресурсу.
      Сообщения ответов сервера на метод PUT не кэшируются.
######PATCH
      Аналогично PUT, но применяется только к фрагменту ресурса.
######DELETE
      Удаляет указанный ресурс.
######TRACE
      Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы
     добавляют или изменяют в запросе.
######CONNECT
      Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению
     защищённого SSL-соединения через нешифрованный прокси.
##Коды состояния
      Код состояния является частью первой строки ответа сервера. Он представляет собой целое число из 
     трёх цифр[5]. Первая цифра указывает на класс состояния. За кодом ответа обычно следует отделённая
     пробелом поясняющая фраза на английском языке, которая разъясняет человеку причину именно такого ответа.
     Примеры:
     - 201 Webpage Created
     - 403 Access allowed only for registered users
     - 507 Insufficient Storage
      Клиент узнаёт по коду ответа о результатах его запроса и определяет, какие действия ему предпринимать
     дальше. Набор кодов состояния является стандартом, и они описаны в соответствующих документах RFC. 
     Введение новых кодов должно производиться только после согласования с IETF. Клиент может не знать все
     коды состояния, но он обязан отреагировать в соответствии с классом кода.
      В настоящее время выделено пять классов кодов состояния.
######1xx Informational («Информационный»)
      В этот класс выделены коды, информирующие о процессе передачи. В HTTP/1.0 сообщения с такими кодами 
     должны игнорироваться. В HTTP/1.1 клиент должен быть готов принять этот класс сообщений как обычный 
     ответ, но ничего отправлять серверу не нужно. Сами сообщения от сервера содержат только стартовую строку
     ответа и, если требуется, несколько специфичных для ответа полей заголовка. Прокси-серверы подобные 
     сообщения должны отправлять дальше от сервера к клиенту.
######2xx Success («Успех»)
      Сообщения данного класса информируют о случаях успешного принятия и обработки запроса клиента. В 
     зависимости от статуса сервер может ещё передать заголовки и тело сообщения.
######3xx Redirection («Перенаправление»)
      Коды класса 3xx сообщают клиенту что для успешного выполнения операции необходимо сделать другой 
     запрос (как правило по другому URI). Из данного класса пять кодов 301, 302, 303, 305 и 307 относятся
     непосредственно к перенаправлениям (редирект). Адрес, по которому клиенту следует произвести запрос,
     сервер указывает в заголовке Location. При этом допускается использование фрагментов в целевом URI.
######4xx Client Error («Ошибка клиента»)
      Класс кодов 4xx предназначен для указания ошибок со стороны клиента. При использовании всех методов,
     кроме HEAD, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя.
######5xx Server Error («Ошибка сервера»)
      Коды 5xx выделены под случаи неудачного выполнения операции по вине сервера. Для всех ситуаций, кроме
     использования метода HEAD, сервер должен включать в тело сообщения объяснение, которое клиент отобразит
     пользователю.
##Заголовки
      Заголовки HTTP (англ. HTTP Headers) — это строки в HTTP-сообщении, содержащие разделённую двоеточием пару 
     параметр-значение. Формат заголовков соответствует общему формату заголовков текстовых сетевых сообщений ARPA
     (см. RFC 822). Заголовки должны отделяться от тела сообщения хотя бы одной пустой строкой.
      Примеры заголовков:
     - Server: Apache/2.2.11 (Win32) PHP/5.3.0
     - Last-Modified: Sat, 16 Jan 2010 21:16:42 GMT
     - Content-Type: text/plain; charset=windows-1251
     - Content-Language: ru
      В примере выше каждая строка представляет собой один заголовок. При этом то, что находится до первого 
     двоеточия, называется именем (англ. name), а что после неё — значением (англ. value).
      Все заголовки разделяются на четыре основных группы:
     1.	General Headers («Основные заголовки») — могут включаться в любое сообщение клиента и сервера.
     2.	Request Headers («Заголовки запроса») — используются только в запросах клиента.
     3.	Response Headers («Заголовки ответа») — только для ответов от сервера.
     4.	Entity Headers («Заголовки сущности») — сопровождают каждую сущность сообщения.
      Именно в таком порядке рекомендуется посылать заголовки получателю.
      Все необходимые для функционирования HTTP заголовки описаны в основных RFC. Если не хватает существующих,
     то можно вводить свои. Традиционно к именам таких дополнительных заголовков добавляют префикс «X-» для 
     избежания конфликта имён с возможно существующими. Например, как в заголовках X-Powered-By или X-Cache.
     Некоторые разработчики используют свои индивидуальные префиксы. Примерами таких заголовков могут служить
     Ms-Echo-Request и Ms-Echo-Reply, введённые корпорацией Microsoft для расширения WebDAV.
##Тело сообщения
     Тело HTTP сообщения (message-body), если оно присутствует, используется для передачи тела объекта,
     связанного с запросом или ответом. Тело сообщения (message-body) отличается от тела объекта (entity-body)
     только в том случае, когда применяется кодирование передачи, что указывается полем заголовка Transfer-Encoding.
     message-body = entity-body
     | <entity-body закодировано согласно
     Transfer-Encoding>
      Поле Transfer-Encoding должно использоваться для указания любого кодирования передачи, примененного 
     приложением в целях гарантирования безопасной и правильной передачи сообщения. Поле Transfer-Encoding
     — это свойство сообщения, а не объекта, и, таким образом, может быть добавлено или удалено любым приложением
     в цепочке запросов/ответов.
      Правила, устанавливающие допустимость тела сообщения в сообщении, отличны для запросов и ответов.
      Присутствие тела сообщения в запросе отмечается добавлением к заголовкам запроса поля заголовка Content-Lengt
     h или Transfer-Encoding. Тело сообщения (message-body) МОЖЕТ быть добавлено в запрос только когда метод 
     запроса допускает тело объекта (entity-body).
      Включается или не включается тело сообщения (message-body) в сообщение ответа зависит как от метода 
     запроса, так и от кода состояния ответа. Все ответы на запрос с методом HEAD не должны включать тело 
     сообщения (message-body), даже если присутствуют поля заголовка объекта (entity-header), заставляющие 
     поверить в присутствие объекта. Никакие ответы с кодами состояния 1xx (Информационные), 204 
     (Нет содержимого, No Content), и 304 (Не модифицирован, Not Modified) не должны содержать тела сообщения
     (message-body). Все другие ответы содержат тело сообщения, даже если оно имеет нулевую длину.
##Обычный GET-запрос
      Запрос клиента:  
      
     GET /wiki/страница HTTP/1.1
     Host: ru.wikipedia.org
     User-Agent: Mozilla/5.0 (X11; U; Linux i686; ru; rv:1.9b5) Gecko/2008050509 Firefox/3.0b5
     Accept: text/html
     Connection: close
     (пустая строка)  
     
     Ответ сервера:  
     
     HTTP/1.1 200 OK
     Date: Wed, 11 Feb 2009 11:20:59 GMT
     Server: Apache
     X-Powered-By: PHP/5.2.4-2ubuntu5wm1
     Last-Modified: Wed, 11 Feb 2009 11:20:59 GMT
     Content-Language: ru
     Content-Type: text/html; charset=utf-8
     Content-Length: 1234
     Connection: close
     (пустая строка)
     (далее следует запрошенная страница в HTML)  
     
      Аналогично выглядит ответ 203. Что существенно, непосредственно запрашиваемые данные отделены от 
     HTTP-заголовков с помощью CRLF CRLF (двух переводов строки).
##Особенности протокола
      Большинство протоколов предусматривают установление TCP-сессии, в ходе которой один раз происходит 
     авторизация, и дальнейшие действия выполняются в контексте этой авторизации. HTTP же устанавливает 
     отдельную TCP-сессию на каждый запрос; в более поздних версиях HTTP было разрешено делать несколько запросов
     в ходе одной TCP-сессии, но браузеры обычно запрашивают только страницу и включённые в неё объекты (картинки,
     каскадные стили и т. п.), а затем сразу разрывают TCP-сессию. Для поддержки авторизованного (неанонимного)
     доступа в HTTP используются cookies; причём такой способ авторизации позволяет сохранить сессию даже после
     перезагрузки клиента и сервера.
      При доступе к данным по FTP или по файловым протоколам тип файла (точнее, тип содержащихся в нём данных)
     определяется по расширению имени файла, что не всегда удобно. HTTP перед тем, как передать сами данные, 
     передаёт заголовок «Content-Type: тип/подтип», позволяющую клиенту однозначно определить, каким образом 
     обрабатывать присланные данные. Это особенно важно при работе с CGI-скриптами, когда расширение имени файла 
     указывает не на тип присылаемых клиенту данных, а на необходимость запуска данного файла на сервере и 
     отправки клиенту результатов работы программы, записанной в этом файле (при этом один и тот же файл в 
     зависимости от аргументов запроса и своих собственных соображений может порождать ответы разных типов — в 
     простейшем случае картинки в разных форматах).
      Кроме того, HTTP позволяет клиенту прислать на сервер параметры, которые будут переданы запускаемому 
     CGI-скрипту. Для этого же в HTML были введены формы.
      Перечисленные особенности HTTP позволили создавать поисковые машины (первой из которых стала AltaVista, 
     созданная фирмой DEC), форумы и Internet-магазины. Это коммерциализировало Интернет, появились компании,
     основным полем деятельности которых стало предоставление доступа в Интернет (провайдеры) и создание сайтов.
##Список использованной литературы 
     1. Гольдштейн Б. С., Соколов Н. А., Яновский Г.Г., Сети связи, 2010
     2. RFC 1945 – HTTP/1.0 Protocol
     3. RFC 2616 – HTTP/1.1 Protocol
     4. Галкин В.А., Григорьев Ю.А., Телекоммуникации и сети, 2003
     5. R.Stevens, B.Fenner, A.Rudoff UNIX Network Programming / Addison Wesley, 2003 – 1024 c., илл. 







