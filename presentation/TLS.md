# TLS

![Рис. 1](http://pro-ldap.ru/tr/zytrax/tech/ssl-layers.gif)

**TLS** ([англ.][1]&nbsp;_Transport Layer Security_ — безопасность транспортного уровня), как и его предшественник [SSL][2] ([англ.][1]&nbsp;_Secure Sockets Layer_&nbsp;— уровень защищённых сокетов)&nbsp;— [криптографические протоколы][3], обеспечивающие защищённую передачу данных между узлами в сети [Интернет][4]. TLS и SSL используют [асимметричную криптографию][5] для аутентификации, [симметричное шифрование][6] для конфиденциальности и [коды аутентичности сообщений][7] для сохранения целостности сообщений.

Данный протокол широко используется в приложениях, работающих с сетью [Интернет][4], таких как [веб-браузеры][8], [работа с электронной почтой][9], [обмен мгновенными сообщениями][10] и [IP-телефония (VoIP)][11]

TLS-протокол основан на спецификации протокола [SSL][2] версии 3.0, разработанной компанией [Netscape Communications][12]. Сейчас развитием стандарта TLS занимается [IETF][13]. Последнее обновление протокола было в [RFC 5246][14] (Август 2008) и [RFC 6176][15] (Март 2011).

## Описание

TLS даёт возможность клиент-серверным приложениям осуществлять связь в сети таким образом, чтобы предотвратить [прослушивание][16] и [несанкционированный доступ][17].

Так как большинство протоколов связи могут быть использованы как с, так и без TLS (или SSL), при установке соединения необходимо явно указать серверу, хочет ли клиент устанавливать TLS. Это может быть достигнуто либо с помощью использования унифицированного [номера порта][18], по которому соединение всегда устанавливается с использованием TLS (как например порт 443 для [HTTPS][19]), либо с использованием произвольного порта и специальной команды серверу со стороны клиента на переключение соединения на TLS с использованием специальных механизмов протокола (как например [STARTTLS][20] для протоколов [электронной почты][9]). Как только клиент и сервер договорились об использовании TLS, им необходимо установить защищённое соединение. Это делается с помощью процедуры подтверждения связи. Во время этого процесса клиент и сервер принимают соглашение относительно различных параметров, необходимых для установки безопасного соединения.

Основные шаги процедуры создания защищённого сеанса связи:

* клиент подключается к серверу, поддерживающему TLS, и запрашивает защищённое соединение;
* клиент предоставляет список поддерживаемых [алгоритмов шифрования][21] и [хеш-функций][22];
* сервер выбирает из списка, предоставленного клиентом, наиболее надёжные алгоритмы среди тех, которые поддерживаются сервером, и сообщает о своём выборе клиенту;
* сервер отправляет клиенту цифровой сертификат для собственной аутентификации. Обычно [цифровой сертификат][23] содержит имя сервера, имя [удостоверяющего центра сертификации][24] и [открытый ключ][25] сервера;
* клиент может связаться с сервером доверенного центра сертификации и подтвердить аутентичность переданного сертификата до начала передачи данных;
* для генерации [сеансового ключа][26] для защищённого соединения клиент шифрует случайно сгенерированную цифровую последовательность открытым ключом сервера и посылает результат на сервер. Учитывая специфику [алгоритма асимметричного шифрования][27], используемого для установления соединения, только сервер может расшифровать полученную последовательность, используя свой закрытый ключ.

На этом заканчивается процедура подтверждения связи. Между клиентом и сервером установлено безопасное соединение, данные, передаваемые по нему, шифруются и расшифровываются с использованием ключа шифрования до тех пор, пока соединение не будет завершено.

При возникновении ошибки на любом из вышеуказанных шагов подтверждение связи завершится с ошибкой и соединение не будет установлено.

## Безопасность

TLS имеет множество мер безопасности:

* Защита от понижения версии протокола к предыдущей (менее защищённой) версии или менее надёжному алгоритму шифрования;
* Нумерация последовательных записей приложения и использование порядкового номера в коде аутентификации сообщения ([MAC][7]);
* Использование ключа в идентификаторе сообщения (только владелец ключа может проверить [код аутентификации сообщения][7]). Хеш-код идентификации сообщений ([HMAC][28]), используемый в большинстве шифров из набора шифров TLS, был определён в [RFC 2104][29];
* Сообщение, которым заканчивается подтверждение связи («Finished»), содержит в себе хэш всех сообщений, которыми обменялись стороны в процессе подтверждения связи;
* Псевдослучайная функция разбивает входные данные на две части и обрабатывает каждую разной хэш-функцией (MD5 и SHA-1), а затем вычисляет XOR от двух полученных свёрток, чтобы создать код аутентификации сообщения. Это обеспечивает безопасность даже в случае уязвимости одной из хэш-функций.

Уязвимость протокола TLS 1.0, которая считалась теоретической, была продемонстрирована на конференции Ekoparty в сентябре 2011 года. Демонстрация включала в себя дешифрование cookies, использованных для аутентификации пользователя.

Уязвимость в фазе возобновления соединения, обнаруженная в августе 2009 года, позволяла [криптоаналитику][30], способному взломать [https-соединение][19], добавлять собственные запросы в сообщения, отправленные от клиента к серверу. Так как [криптоаналитик][30] не может дешифровать переписку сервера и клиента, этот тип атаки отличается от стандартной атаки, типа [человек посередине][31]. В случае, если пользователь не обращает внимания на индикацию браузера о том, что сессия является безопасной (обычно значок замка), уязвимость может быть использована для атаки типа [человек посередине][31]. Для устранения этой уязвимости было предложено как на стороне клиента, так и на стороне сервера добавлять информацию о предыдущем соединении и осуществлять проверку при возобновлении соединения. Это было представлено в стандарте [RFC 5746][32], а также реализовано в последних версиях [OpenSSL][33] и других библиотеках.

Также существуют варианты атак, основанные непосредственно на программной реализации протокола, а не на его алгоритме.

### Процедура подтверждения связи в TLS в деталях

Согласно протоколу TLS приложения обмениваются записями, инкапсулирующими (хранящими внутри себя) информацию, которая должна быть передана. Каждая из записей может быть сжата, дополнена, зашифрована или идентифицирована [MAC][34] (код аутентификации сообщения) в зависимости от текущего состояния соединения (состояния протокола). Каждая запись в TLS содержит следующие поля: content type (определяет тип содержимого записи), поле, указывающее длину пакета, и поле, указывающее версию протокола TLS.

Когда соединение только устанавливается, взаимодействие идёт по протоколу TLS handshake, _content type_ которого 22.

#### Простое подтверждение связи в TLS

Далее показан простой пример установления соединения, при котором сервер (но не клиент) проходит [аутентификацию][35] по его сертификату.

1. Фаза переговоров:
    * Клиент посылает сообщение **ClientHello**, указывая последнюю версию поддерживаемого TLS протокола, случайное число и список поддерживаемых методов шифрования и сжатия, подходящих для работы с TLS;
    * Сервер отвечает сообщением **ServerHello**, содержащим: выбранную сервером версию протокола, случайное число, посланное клиентом, подходящий алгоритм шифрования и сжатия из списка предоставленного клиентом;
    * Сервер посылает сообщение **Certificate**, которое содержит цифровой сертификат сервера (в зависимости от алгоритма шифрования этот этап может быть пропущен);
    * Сервер отсылает сообщение **ServerHelloDone**, идентифицирующее окончание подтверждения связи;
    * Клиент отвечает сообщением **ClientKeyExchange**, которое содержит открытый ключ PreMasterSecret(Этот PreMasterSecret шифруется с помощью открытого ключа сертификата сервера) или ничего (опять же зависит от алгоритма шифрования);
    * Клиент и сервер, используя ключ **PreMasterSecret** и случайно сгенерированные числа, вычисляют общий секретный ключ. Вся остальная информация о ключе будет получена из общего секретного ключа (и сгенерированных клиентом и сервером случайных значений);
2. Клиент посылает сообщение **ChangeCipherSpec**, которое указывает на то, что вся последующая информация будет зашифрована установленным в процессе подтверждения связи алгоритмом, используя общий секретный ключ. Это сообщения уровня записей и поэтому имеет тип 20, а не 22;
    * Клиент посылает сообщение **Finished**, которое содержит хеш и MAC, сгенерированные на основе предыдущих сообщений процедуры подтверждения связи;
    * Сервер пытается расшифровать Finished-сообщение клиента и проверить хеш и МАС. Если процесс расшифровки или проверки не удаётся, подтверждение связи считается неудавшимся, и соединение должно быть оборвано;
3. Сервер посылает **ChangeCipherSpec** и зашифрованное сообщение Finished, и в свою очередь клиент тоже выполняет расшифровку и проверку.

С этого момента подтверждение связи считается завершённым, протокол установленным. Всё последующее содержимое пакетов идет с типом 23, а все данные будут зашифрованы.

#### Подтверждение связи с аутентификацией клиента

В данном примере показана полная [аутентификация][35] клиента (в дополнение к аутентификации сервера, как в предыдущем примере) с помощью обмена сертификатами между сервером и клиентом.

1. Фаза переговоров:
    * Клиент посылает сообщение **ClientHello**, указывая последнюю версию поддерживаемого TLS протокола, случайное число и список поддерживаемых методов шифрования и сжатия, подходящих для работы с TLS;
    * Сервер отвечает сообщением **ServerHello**, содержащим: выбранную сервером версию протокола, случайное число, посланное клиентом, подходящий алгоритм шифрования и сжатия из списка предоставленного клиентом;
    * Сервер посылает сообщение **Certificate**, которое содержит цифровой сертификат сервера (в зависимости от алгоритма шифрования этот этап может быть пропущен);
    * Сервер посылает сообщение **CertificateRequest**, которое содержит запрос сертификата клиента для взаимной проверки подлинности;
    * [_Не хватает пункта получения и проверки сертификата клиента]_;
    * Сервер отсылает сообщение **ServerHelloDone**, идентифицирующее окончание подтверждения связи;
    * Клиент отвечает сообщением **ClientKeyExchange**, которое содержит открытый ключ PreMasterSecret или ничего (опять же зависит от алгоритма шифрования);
    * Клиент и сервер, используя ключ **PreMasterSecret** и случайно сгенерированные числа, вычисляют общий секретный ключ. Вся остальная информация о ключе будет получена из общего секретного ключа (и сгенерированных клиентом и сервером случайных значений);
2. Клиент посылает сообщение **ChangeCipherSpec**, которое указывает на то, что вся последующая информация будет зашифрована установленным в процессе подтверждения связи алгоритмом, используя общий секретный ключ. Это сообщения уровня записей и поэтому имеет тип 20, а не 22;
    * Клиент посылает сообщение **Finished**, которое содержит хеш и MAC, сгенерированные на основе предыдущих сообщений процедуры подтверждения связи;
    * Сервер пытается расшифровать Finished-сообщение клиента и проверить хеш и МАС. Если процесс расшифровки или проверки не удаётся, подтверждение связи считается неудавшимся, и соединение должно быть оборвано.
3. Сервер посылает **ChangeCipherSpec** и зашифрованное сообщение Finished, и в свою очередь клиент тоже выполняет расшифровку и проверку.

С этого момента подтверждение связи считается завершённым, протокол установленным. Всё последующее содержимое пакетов идёт с типом 23, а все данные будут зашифрованы.

#### Возобновление TLS-соединения

Алгоритмы асимметричного шифрования, использующиеся при генерации сеансового ключа, обычно являются дорогими с точки зрения вычислительных мощностей. Для того чтобы избежать их повторения при возобновлении соединения, TLS создаёт специальный ярлык при подтверждении связи, использующийся для возобновления соединения. При этом при обычном подтверждении связи клиент добавляет в сообщение **ClientHello** идентификатор предыдущей сессии _session id_. Клиент связывает идентификатор _session id_ с IP-адресом сервера и TCP-портом так, чтобы при соединении к серверу можно было использовать все параметры предыдущего соединения. Сервер сопоставляет идентификатор предыдущей сессии _session id_ c параметрами соединения, такими как использованный алгоритм шифрования и master secret. Обе стороны должны иметь одинаковый master secret, иначе соединение не будет установлено. Это предотвращает использование _session id_ криптоаналитиком для получения несанкцианированного доступа. Случайные цифровые последовательности в сообщениях **ClientHello** и **ServerHello** позволяют гарантировать, что сгенерированный сеансовый ключ будет отличаться от сеансового ключа при предыдущем соединении. В RFC такой тип подтверждения связи называется _сокращённым_.

1. Фаза переговоров:
    * Клиент посылает сообщение **ClientHello**, указывая последнюю версию поддерживаемого TLS протокола, случайное число и список поддерживаемых методов шифрования и сжатия, подходящих для работы с TLS; Также в сообщение добавляется идентификатор предыдущего соединения **session id**.
    * Сервер отвечает сообщением **ServerHello**, содержащим: выбранную сервером версию протокола, случайное число, посланное клиентом, подходящий алгоритм шифрования и сжатия из списка предоставленного клиентом. Если сервер узнал идентификатор сессии **session id**, то он добавляет в сообщение **ServerHello** тот же самый идентификатор **session id**. Это является сигналом для клиента о том, что можно использовать возобновление предыдущей сессии. Если сервер не узнал идентификатор сессии **session id**, то он добавляет в сообщение **ServerHello**другое значение вместо **session id**. Для клиента это означает, что использовать возобновлённое соединение нельзя. Таким образом, сервер и клиент должны иметь одинаковый master secret и случайные числа для генерации сеансового ключа;
2. Сервер посылает сообщение **ChangeCipherSpec**, которое указывает на то, что вся последующая информация будет зашифрована установленным в процессе подтверждения связи алгоритмом, используя общий секретный ключ. Это сообщения уровня записей и поэтому имеет тип 20, а не 22;
    * Сервер посылает зашифрованное сообщение **Finished**, которое содержит хеш и MAC, сгенерированные на основе предыдущих сообщений процедуры подтверждения связи;
    * Клиент пытается расшифровать **Finished** сообщение сервера и проверить хеш и МАС. Если процесс расшифровки или проверки не удаётся, подтверждение связи считается неудавшимся, и соединение должно быть оборвано;
3. Клиент посылает сообщение **ChangeCipherSpec**, которое указывает на то, что вся последующая информация будет зашифрована установленным в процессе подтверждения связи алгоритмом, используя общий секретный ключ.
    * Клиент посылает своё зашифрованное сообщение **Finished**;
    * Сервер схожим образом пытается расшифровать **Finished** сообщение клиента и проверить хеш и MAC;
4. С этого момента подтверждение связи считается завершённым, протокол установленным. Всё последующее содержимое пакетов идёт с типом 23, а все данные будут зашифрованы.

Кроме преимуществ с точки зрения производительности, алгоритм возобновления соединения может быть использован для реализации [единого входа][36], поскольку гарантируется, что исходной сессия, как и любая возобновлённая сессия, инициирована тем же самым клиентом ([RFC 5077][37]). Это имеет особенно важное значение для реализации [FTPS][38] протокола, который в противном случае был бы уязвим к атаке типа человек посередине, при которой злоумышленник мог бы перехватить содержание данных при установлении повторного соединения.

##### Мандаты сессий

[RFC 5077][37] расширяет TLS через использование мандатов сессий ([англ.][1]&nbsp;_session tickets_), вместо идентификаторов соединений (session id). Он определяет способ возобновления сеанса TLS, не требуя **session id** предыдущей сессии, состояние которой хранится на TLS сервере.

При использовании сессионных мандатов, TLS сервер хранит сеансовое состояние в мандате сеанса и посылает его для хранения на TLS клиенте. Клиент возобновляет TLS сессию отправив мандат сеанса на сервер, а сервер возобновляет TLS сессию в соответствии с параметрами конкретной сессии, сохранёнными в принятом мандате. Сессионный мандат шифруется, в зашифрованном виде проходит аутентификацию на сервере, и сервер проверяет его обоснованность прежде чем использовать содержимое мандата.

Одна из слабостей этого метода&nbsp;— для шифрования и аутентификации передаваемых сессионных мандатов всегда используется только метод AES128-CBC-SHA256, независимо от того, какие параметры TLS выбраны и используются для самого TLS соединения. Это означает, что информация о TLS сессии (сохраняемая в сессионном мандате) не так хорошо защищена, как в рамках самой TLS сессии. Особую озабоченность вызывает хранение OpenSSL ключей в контексте приложения (SSL_CTX) в течение времени жизни приложения, не позволяя их повторного ввода из AES128-CBC-SHA256 сессионных мандатов, без сброса OpenSSL контекста всего приложения (что редкость, подвержено ошибкам и часто требует ручного вмешательства администратора).

## Алгоритмы, использующиеся в TLS

В текущей версии протокола доступны следующие алгоритмы:

* Для обмена ключами и проверки их подлинности применяются комбинации алгоритмов: [RSA][39] (асимметричный шифр), [Diffie-Hellman][40] (безопасный обмен ключами), [DSA][41] (алгоритм цифровой подписи), [ECDSA][42];
* Для симметричного шифрования: [RC4][43], [IDEA][44], [Triple DES][45], [SEED][46], [Camellia][47] или [AES][48];
* Для [хеш-функций][22]: [MD5][49], [SHA][50], [SHA-256/384][51].

Алгоритмы могут дополняться в зависимости от версии протокола. До последней версии протокола TLS 1.2 были доступны также следующие алгоритмы симметричного шифрования, но они были убраны как небезопасные: [RC2][52], [IDEA][44], [DES][53].

## Сравнение с аналогами

Одной из областей применения TLS-соединения является соединение узлов в [виртуальной частной сети][54]. Кроме TLS также могут использоваться набор протоколов [IPSec][55] и [SSH][56]-соединение. Каждый из этих подходов к реализации [виртуальной частной сети][54] имеет свои преимущества и недостатки[17].

1. TLS/SSL
    * Преимущества:
        * Невидим для протоколов более высокого уровня;
        * Популярность использования в Интернет-соединениях и приложениях электронной коммерции;
        * Отсутствие постоянного соединения между сервером и клиентом;
        * Позволяет создать туннель для приложений, использующих [TCP][57], таких как электронная почта, инструменты программирования и&nbsp;т.&nbsp;д.
    * Недостатки:
        * Невозможность использования с протоколами [UDP][58] и [ICMP][59];
        * Необходимость отслеживания состояния соединения;
        * Наличие дополнительных требований к программному обеспечению о поддержке TLS.
2. [IPsec][60]
    * Преимущества:
        * Безопасность и надёжность защиты данных протокола проверена и доказана, так как протокол был принят как Интернет-стандарт;
        * Работа в верхнем слое сетевого протокола и шифрование данных над уровнем сетевого протокола.
    * Недостатки:
        * Сложность реализации;
        * Дополнительные требования к оборудованию сети (маршрутизаторы и&nbsp;т.&nbsp;п.);
        * Существует много различных реализаций, не всегда корректно взаимодействующих друг с другом.
3. [SSH][56]
    * Преимущества:
        * Позволяет создать туннель для приложений, использующих [TCP/IP][61], таких как электронная почта, инструменты программирования и&nbsp;т.&nbsp;д.;
        * Слой безопасности невидим для пользователя.
    * Недостатки:
        * Трудность использования в сетях с большим числом шлюзов, таких как [маршрутизаторы][62] или [брандмауэры][63];
        * Большая нагрузка на внутрисетевой трафик;
        * Невозможность использования с протоколами [UDP][58] и [ICMP][59].
        * Не имеет [PKI][64] (PKI, основанная на [DNSSEC][65], малораспространена).

[1]: https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык"
[2]: https://ru.wikipedia.org/wiki/SSL "SSL"
[3]: https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB "Криптографический протокол"
[4]: https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BD%D0%B5%D1%82 "Интернет"
[5]: https://ru.wikipedia.org/wiki/%D0%90%D1%81%D0%B8%D0%BC%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%8F "Асимметричная криптография"
[6]: https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BC%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B5_%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B "Симметричные криптосистемы"
[7]: https://ru.wikipedia.org/wiki/%D0%98%D0%BC%D0%B8%D1%82%D0%BE%D0%B2%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%B0 "Имитовставка"
[8]: https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%B1-%D0%B1%D1%80%D0%B0%D1%83%D0%B7%D0%B5%D1%80 "Веб-браузер"
[9]: https://ru.wikipedia.org/wiki/E-mail "E-mail"
[10]: https://ru.wikipedia.org/wiki/IM "IM"
[11]: https://ru.wikipedia.org/wiki/VoIP "VoIP"
[12]: https://ru.wikipedia.org/wiki/Netscape_Communications "Netscape Communications"
[13]: https://ru.wikipedia.org/wiki/IETF "IETF"
[14]: //tools.ietf.org/html/rfc5246
[15]: //tools.ietf.org/html/rfc6176
[16]: https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D0%BB%D1%83%D1%88%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5 "Прослушивание"
[17]: https://ru.wikipedia.org/wiki/%D0%9D%D0%B5%D1%81%D0%B0%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF "Несанкционированный доступ"
[18]: https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D1%82_(TCP/IP) "Порт (TCP/IP)"
[19]: https://ru.wikipedia.org/wiki/HTTPS "HTTPS"
[20]: https://ru.wikipedia.org/wiki/STARTTLS "STARTTLS"
[21]: https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5 "Шифрование"
[22]: https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5 "Хеширование"
[23]: https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%BE%D0%B9_%D1%81%D0%B5%D1%80%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82 "Цифровой сертификат"
[24]: https://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BD%D1%82%D1%80_%D1%81%D0%B5%D1%80%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%B8 "Центр сертификации"
[25]: https://ru.wikipedia.org/wiki/%D0%9E%D1%82%D0%BA%D1%80%D1%8B%D1%82%D1%8B%D0%B9_%D0%BA%D0%BB%D1%8E%D1%87 "Открытый ключ"
[26]: https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%B0%D0%BD%D1%81%D0%BE%D0%B2%D1%8B%D0%B9_%D0%BA%D0%BB%D1%8E%D1%87 "Сеансовый ключ"
[27]: https://ru.wikipedia.org/wiki/%D0%90%D1%81%D0%B8%D0%BC%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D1%88%D0%B8%D1%84%D1%80_(%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0) "Асимметричный шифр (криптосистема)"
[28]: https://ru.wikipedia.org/wiki/HMAC "HMAC"
[29]: //tools.ietf.org/html/rfc2104
[30]: https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D1%82%D0%B8%D0%BA "Криптоаналитик"
[31]: https://ru.wikipedia.org/wiki/%D0%A7%D0%B5%D0%BB%D0%BE%D0%B2%D0%B5%D0%BA_%D0%BF%D0%BE%D1%81%D0%B5%D1%80%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5 "Человек посередине"
[32]: //tools.ietf.org/html/rfc5746
[33]: https://ru.wikipedia.org/wiki/OpenSSL "OpenSSL"
[34]: https://ru.wikipedia.org/wiki/Message_authentication_code "Message authentication code"
[35]: https://ru.wikipedia.org/wiki/%D0%90%D1%83%D1%82%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F "Аутентификация"
[36]: https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F_%D0%B5%D0%B4%D0%B8%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B2%D1%85%D0%BE%D0%B4%D0%B0 "Технология единого входа"
[37]: //tools.ietf.org/html/rfc5077
[38]: https://ru.wikipedia.org/wiki/FTPS "FTPS"
[39]: https://ru.wikipedia.org/wiki/RSA "RSA"
[40]: https://ru.wikipedia.org/wiki/Diffie-Hellman "Diffie-Hellman"
[41]: https://ru.wikipedia.org/wiki/DSA "DSA"
[42]: https://ru.wikipedia.org/wiki/ECDSA "ECDSA"
[43]: https://ru.wikipedia.org/wiki/RC4 "RC4"
[44]: https://ru.wikipedia.org/wiki/IDEA "IDEA"
[45]: https://ru.wikipedia.org/wiki/Triple_DES "Triple DES"
[46]: https://ru.wikipedia.org/wiki/SEED "SEED"
[47]: https://ru.wikipedia.org/wiki/Camellia_(%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC) "Camellia (алгоритм)"
[48]: https://ru.wikipedia.org/wiki/Advanced_Encryption_Standard "Advanced Encryption Standard"
[49]: https://ru.wikipedia.org/wiki/MD5 "MD5"
[50]: https://ru.wikipedia.org/wiki/SHA-1 "SHA-1"
[51]: https://ru.wikipedia.org/wiki/SHA-2 "SHA-2"
[52]: https://ru.wikipedia.org/wiki/RC2 "RC2"
[53]: https://ru.wikipedia.org/wiki/DES "DES"
[54]: https://ru.wikipedia.org/wiki/VPN "VPN"
[55]: https://ru.wikipedia.org/wiki/IPSec "IPSec"
[56]: https://ru.wikipedia.org/wiki/SSH "SSH"
[57]: https://ru.wikipedia.org/wiki/TCP "TCP"
[58]: https://ru.wikipedia.org/wiki/UDP "UDP"
[59]: https://ru.wikipedia.org/wiki/ICMP "ICMP"
[60]: https://ru.wikipedia.org/wiki/IPsec "IPsec"
[61]: https://ru.wikipedia.org/wiki/TCP/IP "TCP/IP"
[62]: https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%80%D1%88%D1%80%D1%83%D1%82%D0%B8%D0%B7%D0%B0%D1%82%D0%BE%D1%80%D1%8B "Маршрутизаторы"
[63]: https://ru.wikipedia.org/wiki/Firewall "Firewall"
[64]: https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%84%D1%80%D0%B0%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D1%8B%D1%85_%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B9 "Инфраструктура открытых ключей"
[65]: https://ru.wikipedia.org/wiki/DNSSEC "DNSSEC"
[66]: http://tools.ietf.org/html/rfc5246
[67]: http://www.webcitation.org/65JSRyvms
[68]: http://www.mozilla.org/projects/security/pki/nss/ssl/draft302.txt
[69]: http://technet.microsoft.com/en-us/library/cc785811.aspx
[70]: https://ru.wikipedia.org/w/index.php?title=Microsoft_TechNet&amp;action=edit&amp;redlink=1 "Microsoft TechNet (страница отсутствует)"
[71]: http://www.theregister.co.uk/2011/09/19/beast_exploits_paypal_ssl/
[72]: http://www.webcitation.org/65JSSbOus
[73]: http://www.educatedguesswork.org/2009/11/understanding_the_tls_renegoti.html
[74]: http://www.webcitation.org/65JSTKRCA
[75]: http://www.pcworld.com/article/182720/security_pro_says_new_ssl_attack_can_hit_many_sites.html
[76]: http://www.openssl.org/docs/ssl/SSL_CTX_set_options.html#SECURE_RENEGOTIATION
[77]: http://www.webcitation.org/65JSTpBgx
[78]: http://article.gmane.org/gmane.network.gnutls.general/2046
[79]: http://www.webcitation.org/65JSUYEDA
[80]: https://developer.mozilla.org/NSS_3.12.6_release_notes
[81]: http://www.mail-archive.com/bugtraq@securityfocus.com/msg08807.html
[82]: http://www.webcitation.org/65JSVGzqK
[83]: http://www.ict.kth.se/courses/IK1550/Sample-papers/2G1305_Assignment_Asa_Pehrsson_050908.pdf
[84]: http://www.webcitation.org/65JSVoArr
[85]: http://scarybeastsecurity.blogspot.com/2009/02/vsftpd-210-released.html
[86]: https://media.blackhat.com/us-13/US-13-Daigniere-TLS-Secrets-WP.pdf
[87]: https://media.blackhat.com/us-13/US-13-Daigniere-TLS-Secrets-Slides.pdf
[88]: https://www.imperialviolet.org/2013/06/27/botchingpfs.html
[89]: http://olemartin.com/projects/VPNsolutions.pdf
[90]: http://www.webcitation.org/65JSWNiWC
